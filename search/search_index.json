{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"holden","text":"Version Status Documentation Tools Compatibility Stats"},{"location":"#what-is-holden","title":"What is holden?","text":"<p>This repository is under heavy construction.</p> <p> </p> <p>This package is named after the Roci's captain in The Expanse, James Holden, who was adept at furling his brow and recognizing connections. In a similar vein, holden offers users easy-to-use composite data structures without the overhead or complexity of larger graph packages. The included graphs are built for basic workflow design or analysis of conditional relationships. They are not designed for big data network analysis or similar large-scale projects (although nothing prevents you from using them in that manner). Rather, the goal of holden is to provide lightweight, turnkey, extensible composite data structures without all of the stuff you don't need in packages like networkx. holden serves as the base for my chrisjen workflow package (similarly named for a character from The Expanse), but I have made holden available separately for easier integration into other uses.</p>"},{"location":"#why-use-holden","title":"Why use holden?","text":""},{"location":"#simple","title":"Simple","text":"<p>The basic building blocks provided are: * <code>Composite</code>: the abstract base class for all types of a composite data structures * <code>Graph</code>: subclass of Composite and the base class for all graph data structures * <code>Edge</code>: an optional edge class which can be treated as a drop-in tuple replacement or extended for greater functionality * <code>Node</code>: an optional vertex class which provides universal hashability and some other convenient functions * <code>Forms</code>: a dictionary that automatically stores all direct Compisite subclasses to allow flexible subtype checking of and transformation between composite subtypes using its <code>classify</code> and <code>transform</code> methods</p> <p>Out of the box, Graph has several subtypes with varying internal storage formats: * <code>Adjacency</code>: an adjacency list using a <code>dict(Node, set(Node))</code> structure * <code>Matrix</code>: an adjacency matrix that uses a <code>list[list[float | int]]</code> for mapping edges and a separate <code>list[str]</code> attribute that corresponds to the list of lists matrix * <code>Edges</code>: an edge list structure that uses a <code>list[tuple[Node, Node]]</code> format</p> <p>You can use holden without any regard to what is going on inside the graph. The methods and properties are the same regardless of which internal format is used. But the different forms are provided in case you want to utilize the advantages or avoid certain drawbacks of a particular form. Unless you want to design a different graph form, you should design subclasses to inherit from one of the included forms and add mixins to expand functionality.</p>"},{"location":"#flexible","title":"Flexible","text":"<p>Various traits can be added to graphs, nodes, and edges as mixins including: * Weighted edges (<code>Weighted</code>) * Abilty to create a graph from or convert any graph to any recognized form using properties with consistent syntax (<code>Fungible</code>) * Directed graphs (<code>Directed</code>) * Automatically names objects if a name is not passed (<code>Labeled</code>) * Has methods to convert and export to other graph formats (<code>Exportable</code>) * Ability to store node data internally for easy reuse separate from the graph structure (<code>Storage</code>)</p> <p>holden provides transformation methods between all of the internal storage forms as well as functions to convert graphs into a set of paths (<code>Parallel</code>) or a single path (<code>Serial</code>). The transformation methods can be used as class properties or with functions using an easy-to-understand naming convention (e.g., adjacency_to_edges or edges_to_parallel).</p> <p>holden's framework supports a wide range of coding styles. You can create complex multiple inheritance structures with mixins galore or simpler, compositional objects. Even though the data structures are necessarily object-oriented, all of the tools to modify them are also available as functions, for those who prefer a more functional approaching to programming.</p> <p>The package also uses structural subtyping that allows raw forms of the supported composite subtypes to be used and recognized as the same forms for which holden includes classes. So, for example, the is_adjacency function will recognize any object with a dict(Node, set(Node)) structure and isinstance(item, holden.Adjacency) will similarly return True for a raw adjacency list.</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#requirements","title":"Requirements","text":"<p>[TODO: List any OS or other restrictions and pre-installation dependencies]</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>holden</code>, use <code>pip</code>:</p> <pre><code>pip install holden\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>[TODO: Describe common use cases, with possible example(s)]</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributors are always welcome. Feel free to grab an issue to work on or make a suggested improvement. If you wish to contribute, please read the Contribution Guide and Code of Conduct.</p>"},{"location":"#similar-projects","title":"Similar Projects","text":"<ul> <li>networkx: the market leader for python graphs. Offers greater flexibility and extensibility at the cost of substantial overhead.</li> </ul>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>[TODO: Mention any people or organizations that warrant a special acknowledgment]</p>"},{"location":"#license","title":"License","text":"<p>Use of this repository is authorized under the Apache Software License 2.0.</p> <p> </p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#019","title":"0.1.9","text":"<pre><code>* Cleaned up documentation from docstrings\n* Added mermaid.js exporter\n</code></pre>"},{"location":"changelog/#018","title":"0.1.8","text":"<pre><code>* Transitioned to `snickerdoodle` `cookiecutter` template\n* Removed extra dependencies\n* Updated class names from `bunches` package\n</code></pre>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting any of the following people:</p> <ul> <li>Corey Rayburn Yung (coreyrayburnyung@gmail.com)</li> </ul> <p>All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated! Every little bit helps, and credit will always be given. Environment Setup</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Follow this basic process:</p> <ol> <li>Fork and clone the repositor.</li> <li>Create a new branch: <code>git checkout -b feature-or-bugfix-name</code>.</li> <li>Edit the code.</li> <li>If you added functionality or features, update the documentation accordingly.</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>This package follows the Google Python Style Guide with two notable exceptions:</p> <ol> <li>It always adds spaces around \"=\". This not only violates the Google guide, it violates PEP8, the foundational Python style guide from which all other resources are derived. I defy this strong, long-standign norm because I find it more readable. My brain and eyes have trouble seeing two separate objects when an equal sign is in the middle. I imagine that I am not alone in this accessibility issue. Further, as PEP8 itself notes, required spaces around equal signs are becoming increasing common with type annotations becoming part of best practices (and, as a result, signatures to classes, functions, and methods regularly include spaces around the equal signs). I realize that this will seem alien to many coders, but it is far easier on my eyes.</li> <li>I use some so-called \"power features\", primarily dunder methods, to make my interfaces easier to access and use. This is disfavored in the Google Python Style Guide because such code is often more difficult for others to read. To address that concern, I try to document and comment as to what the code is doing whenever I used any of the \"power features\" of Python.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<pre><code>Traceback (most recent call last):\n  File \"/home/runner/work/holden/holden/.venv/lib/python3.13/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/work/holden/holden/.venv/lib/python3.13/site-packages/markdown_exec/formatters/_exec_python.py\", line 7, in exec_python\n    compiled = compile(code, filename=filename, mode=\"exec\")\n  File \"&lt;code block: n1&gt;\", line 81\n    chain( [arg-type]\n           ^^^^^^^^^^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\n</code></pre>"},{"location":"license/","title":"License","text":"<p>Apache Software License 2.0</p> <p>Copyright \u00a9 2024, Corey Rayburn Yung</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> holden<ul> <li> applications</li> <li> base</li> <li> check</li> <li> composites</li> <li> export</li> <li> graphs</li> <li> options</li> <li> report</li> <li> traits</li> <li> traverse</li> <li> utilities</li> <li> workshop</li> </ul> </li> </ul>"},{"location":"reference/holden/","title":"Index","text":"<p>Lightweight, easy-to-use, flexible composite data structures.</p>"},{"location":"reference/holden/#holden.Adjacency","title":"<code>Adjacency(contents=lambda: collections.defaultdict(set)())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Graph</code>, <code>Dictionary</code></p> <p>Base class for adjacency-list graphs.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, set[Hashable]]</code> <p>keys are hashable representations of nodes. Values are the nodes to which the key node are connected. In a directed graph, the key node is assumed to come before the value node in order. Defaults to a defaultdict that has a set for its value type.</p> <code>lambda: defaultdict(set)()</code>"},{"location":"reference/holden/#holden.Adjacency.contents","title":"<code>contents = dataclasses.field(default_factory=lambda: collections.defaultdict(set))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private Methods</p>"},{"location":"reference/holden/#holden.Adjacency._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored graph.\n\n    Args:\n        item: node to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents[item] = set()\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Adjacency._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _connect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents[item[0]].add(item[1])\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Adjacency._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored graph.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    del self.contents[item]\n    self.contents = {k: v.remove(item) for k, v in self.contents.items()}\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Adjacency._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _disconnect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents[item[0]].remove(item[1])\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Adjacency._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines 'item' with the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph object to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _merge(self, item: base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Combines 'item' with the stored graph.\n\n    Args:\n        item: another Graph object to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'adjacency',\n        raise_same_error = False)\n    for node, edges in other.items():\n        if node in self:\n            self[node].update(edges)\n        else:\n            self[node] = edges\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Adjacency._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new graph without a subset of <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Union[Hashable, Sequence[Hashable]]</code> <p>nodes or edges which should be included in the new graph.</p> <code>None</code> <code>exclude</code> <code>Union[Hashable, Sequence[Hashable]]</code> <p>nodes or edges which should not be included in the new graph.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Adjacency</code> <code>Adjacency</code> <p>with only selected nodes and edges.</p> Source code in <code>src/holden/graphs.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Adjacency:\n    \"\"\"Returns a new graph without a subset of `contents`.\n\n    Args:\n        include (Union[Hashable, Sequence[Hashable]]): nodes or edges which\n            should be included in the new graph.\n        exclude (Union[Hashable, Sequence[Hashable]]): nodes or edges which\n            should not be included in the new graph.\n\n    Returns:\n       Adjacency: with only selected nodes and edges.\n\n    \"\"\"\n    excludables = [\n        k for k in self.contents if k not in include] if include else []\n    excludables.extend([i for i in self.contents if i in exclude])\n    new_graph = copy.deepcopy(self)\n    for node in utilities._iterify(excludables):\n        new_graph.delete(node = node)\n    return new_graph\n</code></pre>"},{"location":"reference/holden/#holden.Composite","title":"<code>Composite(contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for composite data structures.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Collection[Any] | None</code> <p>stored nodes or node labels. Subclasses should narrow the type for contents based on the internal storage format used.</p> <code>None</code>"},{"location":"reference/holden/#holden.Composite.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/#holden.Composite._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for adding a single node. The provided <code>add</code> method offers all of the error checking and the ability to add multiple nodes at once. Subclasses just need to provide the mechanism for adding a single node without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite data structure.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite data structure.\n\n    Subclasses must provide their own specific methods for adding a single\n    node. The provided `add` method offers all of the error checking and\n    the ability to add multiple nodes at once. Subclasses just need to\n    provide the mechanism for adding a single node without worrying about\n    validation or error-checking.\n\n    Args:\n        item: node to add to the stored composite data structure.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Composite._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for deleting a single node. The provided <code>delete</code> method offers all of the error checking and the ability to delete multiple nodes at once. Subclasses just need to provide the mechanism for deleting a single node without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite data structure.\n\n    Subclasses must provide their own specific methods for deleting a single\n    node. The provided `delete` method offers all of the error checking and\n    the ability to delete multiple nodes at once. Subclasses just need to\n    provide the mechanism for deleting a single node without worrying about\n    validation or error-checking.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Composite._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for merging with another composite data structure. The provided <code>merge</code> method offers all of the error checking. Subclasses just need to provide the mechanism for merging without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite object to add to the stored composite data structure.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _merge(self, item: Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored composite data structure.\n\n    Subclasses must provide their own specific methods for merging with\n    another composite data structure. The provided `merge` method offers all\n    of the error checking. Subclasses just need to provide the mechanism for\n    merging without worrying about validation or error-checking.\n\n    Args:\n        item: another Composite object to add to the stored\n            composite data structure.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Composite._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new Composite without a subset of <code>contents</code>.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. Subclasses just need to provide the mechanism for returning a subset without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite data structure.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite data structure.</p> <code>None</code> <p>Returns:</p> Type Description <code>Composite</code> <p>Graph with only selected nodes and edges.</p> Source code in <code>src/holden/base.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Composite:\n    \"\"\"Returns a new Composite without a subset of `contents`.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. Subclasses just need to provide the mechanism for returning a\n    subset without worrying about validation or error-checking.\n\n    Args:\n        include: nodes or edges which\n            should be included in the new composite data structure.\n        exclude: nodes or edges which\n            should not be included in the new composite data structure.\n\n    Returns:\n       Graph with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Composite.add","title":"<code>add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite data structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite data structure.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is not a node type.</p> <code>ValueError</code> <p>if <code>item</code> is already in the stored composite data structure.</p> Source code in <code>src/holden/base.py</code> <pre><code>def add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite data structure.\n\n    Args:\n        item: node to add to the stored composite data structure.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        TypeError: if `item` is not a node type.\n        ValueError: if `item` is already in the stored composite data\n            structure.\n\n    \"\"\"\n    if not check.is_node(item = item):\n        raise TypeError(f'{item} is not a node type')\n    if item in self.contents:\n        raise ValueError(\n            f'{item} is already in the composite data structure')\n    self._add(item, **kwargs)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Composite.delete","title":"<code>delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for deleting a single node. The provided <code>delete</code> method offers all of the error checking and the ability to delete multiple nodes at once. Subclasses just need to provide the mechanism for deleting a single node without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if <code>item</code> is not in <code>contents</code>.</p> <code>TypeError</code> <p>if <code>item</code> is not in <code>contents</code>.</p> Source code in <code>src/holden/base.py</code> <pre><code>def delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite data structure.\n\n    Subclasses must provide their own specific methods for deleting a single\n    node. The provided `delete` method offers all of the error checking and\n    the ability to delete multiple nodes at once. Subclasses just need to\n    provide the mechanism for deleting a single node without worrying about\n    validation or error-checking.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        KeyError: if `item` is not in `contents`.\n        TypeError: if `item` is not in `contents`.\n\n    \"\"\"\n    if not check.is_node(item = item):\n        raise TypeError(f'{item} is not a node type')\n    try:\n        self._delete(item, **kwargs)\n    except KeyError as e:\n        message = f'{item} does not exist in the composite data structure'\n        raise KeyError(message) from e\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Composite.merge","title":"<code>merge(item, **kwargs)</code>","text":"<p>Adds <code>item</code> to this Composite.</p> <p>This method is roughly equivalent to a dict.update, just adding <code>item</code> to the existing stored composite data structure while maintaining its structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite to merge with</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is not compatible composite data structure type.</p> Source code in <code>src/holden/base.py</code> <pre><code>def merge(self, item: Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Adds `item` to this Composite.\n\n    This method is roughly equivalent to a dict.update, just adding `item`\n    to the existing stored composite data structure while maintaining its\n    structure.\n\n    Args:\n        item: another Composite to merge with\n        kwargs: additional keyword arguments.\n\n    Raises:\n        TypeError: if `item` is not compatible composite data structure\n            type.\n\n    \"\"\"\n    if not check.is_composite(item = item):\n        raise TypeError(f'{item} is not a compatible type')\n    self._merge(item, **kwargs)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Composite.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new Composite without a subset of <code>contents</code>.</p> <p>All edges will be removed that include any nodes that are not part of the new composite data structure.</p> <p>Any extra attributes that are part of a Composite (or a subclass) should be maintained in the returned composite data structure.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite data structure.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite data structure.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if include and exclude are none or if any item in include or exclude is not in the stored composite data structure.</p> <p>Returns:</p> Type Description <code>Composite</code> <p>Composite with only selected nodes and edges.</p> Source code in <code>src/holden/base.py</code> <pre><code>def subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Composite:\n    \"\"\"Returns a new Composite without a subset of `contents`.\n\n    All edges will be removed that include any nodes that are not part of\n    the new composite data structure.\n\n    Any extra attributes that are part of a Composite (or a subclass) should\n    be maintained in the returned composite data structure.\n\n    Args:\n        include: nodes or edges which should be included in the new\n            composite data structure.\n        exclude: nodes or edges which should not be included in the new\n            composite data structure.\n\n    Raises:\n        ValueError: if include and exclude are none or if any item in\n            include or exclude is not in the stored composite data\n            structure.\n\n    Returns:\n       Composite with only selected nodes and edges.\n\n    \"\"\"\n    if include is None and exclude is None:\n        raise ValueError('Either include or exclude must not be None')\n    if not all(i for i in include if i in self.contents):\n        raise ValueError(\n            'Some values in include are not in the composite data '\n            'structure')\n    if not all(i for i in exclude if i in self.contents):\n        raise ValueError(\n            'Some values in exclude are not in the composite data '\n            'structure')\n    return self._subset(include, exclude)\n</code></pre>"},{"location":"reference/holden/#holden.Directed","title":"<code>Directed(contents)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for directed graph data structures.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Collection[Any]</code> <p>stored collection of nodes and/or edges.</p> required"},{"location":"reference/holden/#holden.Directed.contents","title":"<code>contents</code>  <code>instance-attribute</code>","text":"<p>Required Subclass Properties</p>"},{"location":"reference/holden/#holden.Directed.endpoint","title":"<code>endpoint</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns the endpoint(s) of the stored composite.</p>"},{"location":"reference/holden/#holden.Directed.root","title":"<code>root</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns the root(s) of the stored composite.</p>"},{"location":"reference/holden/#holden.Directed.append","title":"<code>append(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Appends <code>item</code> to the endpoint(s) of the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable | Graph</code> <p>a Node or Graph to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/traits.py</code> <pre><code>@abc.abstractmethod\ndef append(self, item: Hashable | base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Appends `item` to the endpoint(s) of the stored composite.\n\n    Args:\n        item: a Node or Graph to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/holden/#holden.Directed.prepend","title":"<code>prepend(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Prepends <code>item</code> to the root(s) of the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable | Graph</code> <p>a Node or Graph to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/traits.py</code> <pre><code>@abc.abstractmethod\ndef prepend(self, item: Hashable | base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Prepends `item` to the root(s) of the stored composite.\n\n    Args:\n        item: a Node or Graph to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/holden/#holden.Directed.walk","title":"<code>walk(start=None, stop=None, path=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns path in the stored composite from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>Node to start paths from. Defaults to None. If it is None, <code>start</code> will be assigned to <code>stop</code>.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>Node to stop paths at. Defaults to None. If it is None, <code>stop</code> will be assigned to <code>endpoint</code>.</p> <code>None</code> <code>path</code> <code>Path | None</code> <p>a path from <code>start</code> to <code>stop</code>. Defaults to None. This parameter is used for recursively determining a path.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path(s) through the graph.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@abc.abstractmethod\ndef walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None,\n    path: base.Path | None = None,\n    **kwargs: Any) -&gt; base.Path:\n    \"\"\"Returns path in the stored composite from `start` to `stop`.\n\n    Args:\n        start: Node to start paths from. Defaults to None. If it is None,\n            `start` will be assigned to `stop`.\n        stop: Node to stop paths at. Defaults to None. If it is None,\n            `stop` will be assigned to `endpoint`.\n        path: a path from `start` to `stop`. Defaults to None. This\n            parameter is used for recursively determining a path.\n        kwargs: additional keyword arguments.\n\n    Returns:\n        Path(s) through the graph.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/holden/#holden.Edge","title":"<code>Edge(start, stop)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Sequence</code></p> <p>Base class for an edge in a graph structure.</p> <p>Edges are not required for most of the base graph classes in holden. But they can be used by subclasses of those base classes for more complex data structures.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable</code> <p>starting point for the edge.</p> required <code>stop</code> <code>Hashable</code> <p>stopping point for the edge.</p> required"},{"location":"reference/holden/#holden.Edge.stop","title":"<code>stop</code>  <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/holden/#holden.Edges","title":"<code>Edges(contents=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Graph</code>, <code>Listing</code></p> <p>Base class for edge-list graphs.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Edge]</code> <p>Listing of edges. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/#holden.Edges.contents","title":"<code>contents = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private Methods</p>"},{"location":"reference/holden/#holden.Edges._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _add(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Edges._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _connect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Edges._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _delete(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.remove(item)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Edges._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _disconnect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.remove(item)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Edges._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines 'item' with the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph object to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _merge(self, item: base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Combines 'item' with the stored graph.\n\n    Args:\n        item: another Graph object to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'edges',\n        raise_same_error = False)\n    self.contents.extend(other)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Edges._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new graph without a subset of <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new graph.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency with only selected nodes and edges.</p> Source code in <code>src/holden/graphs.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Adjacency:\n    \"\"\"Returns a new graph without a subset of `contents`.\n\n    Args:\n        include: nodes or edges which should be included in the new graph.\n        exclude: nodes or edges which should not be included in the new\n            graph.\n\n    Returns:\n       Adjacency with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Exportable","title":"<code>Exportable()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin for exporting graphs to other formats.</p>"},{"location":"reference/holden/#holden.Exportable.to_dot","title":"<code>to_dot(path=None, name=None, settings=None)</code>","text":"<p>Converts the stored composite to a dot format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>path to export to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>name to put in the dot str. Defaults to None.</p> <code>None</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the dot graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in graphviz dot format.</p> Source code in <code>src/holden/traits.py</code> <pre><code>def to_dot(\n    self,\n    path: str | pathlib.Path | None = None,\n    name: str | None = None,\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts the stored composite to a dot format.\n\n    Args:\n        path: path to export to. Defaults to None.\n        name: name to put in the dot str. Defaults to None.\n        settings: any global settings to add to the dot graph. Defaults to\n            None.\n\n    Returns:\n        Composite object in graphviz dot format.\n\n    \"\"\"\n    name = name or utilities._namify(self)\n    return export.to_dot(\n        item = self,\n        path = path,\n        name = name,\n        settings = settings)\n</code></pre>"},{"location":"reference/holden/#holden.Exportable.to_mermaid","title":"<code>to_mermaid(path=None, name=None, settings=None)</code>","text":"<p>Converts the stored composite to a mermaid format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>path to export to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>name to put in the mermaid str. Defaults to None.</p> <code>None</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the mermaid graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in mermaid format.</p> Source code in <code>src/holden/traits.py</code> <pre><code>def to_mermaid(\n    self,\n    path: str | pathlib.Path | None = None,\n    name: str | None = None,\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts the stored composite to a mermaid format.\n\n    Args:\n        path: path to export to. Defaults to None.\n        name: name to put in the mermaid str. Defaults to None.\n        settings: any global settings to add to the mermaid graph. Defaults\n            to None.\n\n    Returns:\n        Composite object in mermaid format.\n\n    \"\"\"\n    name = name or utilities._namify(self)\n    return export.to_mermaid(\n        item = self,\n        path = path,\n        name = name,\n        settings = settings)\n</code></pre>"},{"location":"reference/holden/#holden.Forms","title":"<code>Forms()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registrar</code></p> <p>Registry of composite data structures.</p> <p>Attributes:</p> Name Type Description <code>registry</code> <code>GenericDict</code> <p>stores classes and/or instances to be used in item construction. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/holden/#holden.Forms.registry","title":"<code>registry = {}</code>  <code>class-attribute</code>","text":"<p>Public Methods</p>"},{"location":"reference/holden/#holden.Forms.classify","title":"<code>classify(item)</code>  <code>classmethod</code>","text":"<p>Determines which form of composite that <code>item</code> is.</p> <p>There is no difference between this classmethod and the <code>classify</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>object to classify.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name of form that <code>item</code> is.</p> Source code in <code>src/holden/base.py</code> <pre><code>@classmethod\ndef classify(cls, item: object) -&gt; str:\n    \"\"\"Determines which form of composite that `item` is.\n\n    There is no difference between this classmethod and the `classify`\n    function.\n\n    Args:\n        item: object to classify.\n\n    Returns:\n        Name of form that `item` is.\n\n    \"\"\"\n    return classify(item)\n</code></pre>"},{"location":"reference/holden/#holden.Forms.register","title":"<code>register(item, name=None)</code>  <code>classmethod</code>","text":"<p>Adds <code>item</code> to <code>registry</code>.</p> <p>The key assigned for storing <code>item</code> is determined using the _namify function if <code>name</code> is not passed.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Composite]</code> <p>class to register.</p> required <code>name</code> <code>str | None</code> <p>key to use for storing <code>item</code>. Defaults to None.</p> <code>None</code> Source code in <code>src/holden/base.py</code> <pre><code>@classmethod\ndef register(cls, item: type[Composite], name: str | None = None) -&gt; None:\n    \"\"\"Adds `item` to `registry`.\n\n    The key assigned for storing `item` is determined using the _namify\n    function if `name` is not passed.\n\n    Args:\n        item: class to register.\n        name: key to use for storing `item`. Defaults to None.\n\n    \"\"\"\n    name = name or utilities._namify(item)\n    cls.registry[name] = item\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Forms.transform","title":"<code>transform(item, output, *, raise_same_error=True)</code>  <code>classmethod</code>","text":"<p>General transform method that will call appropriate transformer.</p> <p>Unlike the <code>transform</code> function, this method will return a Composite wrapped in the form type stored in the Forms registry (as opposed to the raw type). So, if <code>output</code> is <code>edges</code>, this method will return an edge list in the Edges class. In contrast, the <code>transform</code> method will return the structural type of an edge list without using the Edges class. The rest of the logic is identical between the function and method.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>Composite to transform.</p> required <code>output</code> <code>str</code> <p>name of form to transform <code>item</code> to.</p> required <code>raise_same_error</code> <code>bool | None</code> <p>whether to return an error if the form of <code>item</code> is the same as <code>output</code>. If True, a ValueError will be returned. If False, item will be return without any change. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the form of <code>item</code> is the same as <code>output</code> and <code>raise_same_error</code> is True.</p> <p>Returns:</p> Type Description <code>Composite</code> <p>Transformed composite data structure.</p> Source code in <code>src/holden/base.py</code> <pre><code>@classmethod\ndef transform(\n    cls,\n    item: Composite,\n    output: str, *,\n    raise_same_error: bool | None = True) -&gt; Composite:\n    \"\"\"General transform method that will call appropriate transformer.\n\n    Unlike the `transform` function, this method will return a Composite\n    wrapped in the form type stored in the Forms registry (as opposed to the\n    raw type). So, if `output` is `edges`, this method will return an edge\n    list in the Edges class. In contrast, the `transform` method will return\n    the structural type of an edge list without using the Edges class. The\n    rest of the logic is identical between the function and method.\n\n    Args:\n        item: Composite to transform.\n        output: name of form to transform `item` to.\n        raise_same_error: whether to return an error if the form of `item`\n            is the same as `output`. If True, a ValueError will be returned.\n            If False, item will be return without any change. Defaults to\n            True.\n\n    Raises:\n        ValueError: if the form of `item` is the same as `output` and\n            `raise_same_error` is True.\n\n    Returns:\n        Transformed composite data structure.\n\n    \"\"\"\n    form = cls.classify(item)\n    if form == output and raise_same_error:\n        raise ValueError('The passed item and output are the same type')\n    if form == output:\n        return item\n    transformer = getattr(workshop, [f'{form}_to_{output}'])\n    return cls.registry[output](contents = transformer(item = item))\n</code></pre>"},{"location":"reference/holden/#holden.Fungible","title":"<code>Fungible()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin requirements for graphs that can be internally transformed.</p>"},{"location":"reference/holden/#holden.Fungible.adjacency","title":"<code>adjacency</code>  <code>property</code>","text":"<p>Returns the stored composite as an Adjacency.</p>"},{"location":"reference/holden/#holden.Fungible.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>Returns the stored composite as an Edges.</p>"},{"location":"reference/holden/#holden.Fungible.matrix","title":"<code>matrix</code>  <code>property</code>","text":"<p>Returns the stored composite as a Matrix.</p>"},{"location":"reference/holden/#holden.Fungible.parallel","title":"<code>parallel</code>  <code>property</code>","text":"<p>Returns the stored composite as a Parallel.</p>"},{"location":"reference/holden/#holden.Fungible.serial","title":"<code>serial</code>  <code>property</code>","text":"<p>Returns the stored composite as a Serial.</p>"},{"location":"reference/holden/#holden.Fungible.from_adjacency","title":"<code>from_adjacency(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from an Adjacency.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_adjacency(cls, item: graphs.Adjacency) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from an Adjacency.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/#holden.Fungible.from_edges","title":"<code>from_edges(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from an Edges.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_edges(cls, item: graphs.Edges) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from an Edges.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/#holden.Fungible.from_matrix","title":"<code>from_matrix(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from a Matrix.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_matrix(cls, item: graphs.Matrix) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from a Matrix.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/#holden.Fungible.from_parallel","title":"<code>from_parallel(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from a Parallel.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_parallel(cls, item: composites.Parallel) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from a Parallel.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/#holden.Fungible.from_serial","title":"<code>from_serial(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from a Serial.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_serial(cls, item: composites.Serial) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from a Serial.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/#holden.Graph","title":"<code>Graph(contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Composite</code>, <code>ABC</code></p> <p>Base class for holden graphs.</p> <p>Graph adds the requirements of <code>_connect</code> and <code>_disconnect</code> methods in addition to the requirements of Composite.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Collection[Any] | None</code> <p>stored nodes, node labels, edges, or edge labels. Subclasses should narrow the type for contents based on the internal storage format used.</p> <code>None</code>"},{"location":"reference/holden/#holden.Graph.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/#holden.Graph._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Subclasses must provide their own specific methods for adding a single edge. The provided <code>connect</code> method offers all of the error checking and the ability to add multiple edges at once. Subclasses just need to provide the mechanism for adding a single edge without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _connect(self, item: Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Subclasses must provide their own specific methods for adding a single\n    edge. The provided `connect` method offers all of the error checking and\n    the ability to add multiple edges at once. Subclasses just need to\n    provide the mechanism for adding a single edge without worrying about\n    validation or error-checking.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Graph._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. The provided <code>disconnect</code> method offers all of the error checking and the ability to delete multiple edges at once. Subclasses just need to provide the mechanism for deleting a single edge without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _disconnect(self, item: Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. The provided `disconnect` method offers all of the error checking\n    and the ability to delete multiple edges at once. Subclasses just need\n    to provide the mechanism for deleting a single edge without worrying\n    about validation or error-checking.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Graph.connect","title":"<code>connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the ends of the item are the same or if one of the edge ends does not currently exist in the stored graph.</p> Source code in <code>src/holden/base.py</code> <pre><code>def connect(self, item: Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        ValueError: if the ends of the item are the same or if one of the\n            edge ends does not currently exist in the stored graph.\n\n    \"\"\"\n    if not check.is_edge(item = item):\n        raise TypeError(f'{item} is not an edge type')\n    if item[0] == item[1]:\n        raise ValueError(\n            'The starting point of an edge cannot be the same as the '\n            'ending point')\n    if item[0] not in self:\n        raise ValueError(f'{item[0]} is not in the graph')\n    if item[1] not in self:\n        raise ValueError(f'{item[1]} is not in the graph')\n    self._connect(item, **kwargs)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Graph.disconnect","title":"<code>disconnect(item, *kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the edge does not exist in the stored graph.</p> Source code in <code>src/holden/base.py</code> <pre><code>def disconnect(self, item: Edge, *kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        ValueError: if the edge does not exist in the stored graph.\n\n    \"\"\"\n    if not check.is_edge(item = item):\n        raise TypeError(f'{item} is not an edge type')\n    if item[0] == item[1]:\n        raise ValueError(\n            'The starting point of an edge cannot be the same as the '\n            'ending point')\n    try:\n        self._disconnect(item, **kwargs)\n    except (KeyError, ValueError) as e:\n        message = f'The edge ({item[0]}, {item[1]}) is not in the graph'\n        raise ValueError(message) from e\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Labeled","title":"<code>Labeled(name=None, contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin for labeling a composite object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>designates the name of a class instance that is used for internal and external referencing in a composite object. Defaults to None.</p> <code>None</code> <code>contents</code> <code>Any | None</code> <p>any stored item(s). Defaults to None.</p> <code>None</code>"},{"location":"reference/holden/#holden.Labeled.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/#holden.Labeled._namify","title":"<code>_namify()</code>","text":"<p>Returns str name of an instance.</p> <p>By default, if <code>contents</code> is None, 'none' will be returned. Otherwise, <code>utilities._namify</code> will be called based on the value of the <code>contents</code> attribute and its return value will be returned.</p> <p>For different naming rules, subclasses should override this method, which is automatically called when an instance is initialized.</p> <p>Returns:</p> Type Description <code>str</code> <p>str label for part of a composite data structute.</p> Source code in <code>src/holden/traits.py</code> <pre><code>def _namify(self) -&gt; str:\n    \"\"\"Returns str name of an instance.\n\n    By default, if `contents` is None, 'none' will be returned. Otherwise,\n    `utilities._namify` will be called based on the value of the `contents`\n    attribute and its return value will be returned.\n\n    For different naming rules, subclasses should override this method,\n    which is automatically called when an instance is initialized.\n\n    Returns:\n        str label for part of a composite data structute.\n\n    \"\"\"\n    return 'none' if self.contents is None else utilities._namify(self.contents)\n</code></pre>"},{"location":"reference/holden/#holden.Matrix","title":"<code>Matrix(contents=list(), labels=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Graph</code>, <code>Listing</code></p> <p>Base class for adjacency-matrix graphs.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[MutableSequence[int]]</code> <p>a list of list of integers indicating edges between nodes in the matrix. Defaults to an empty list.</p> <code>list()</code> <code>labels</code> <code>MutableSequence[Hashable]</code> <p>names of nodes in the matrix. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/#holden.Matrix.labels","title":"<code>labels = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private Methods</p>"},{"location":"reference/holden/#holden.Matrix._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _add(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Matrix._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _connect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Matrix._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _delete(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Matrix._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _disconnect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Matrix._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph object to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _merge(self, item: base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored graph.\n\n    Args:\n        item: another Graph object to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'matrix',\n        raise_same_error = False)\n    new_matrix = other[0]\n    length = len(self.contents)\n    for row in enumerate(new_matrix):\n        for column in enumerate(row):\n            self.contents[row + length][column + length] = (\n                new_matrix[row][column])\n    self.labels.extend(other[1])\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Matrix._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new graph without a subset of <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new graph.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency with only selected nodes and edges.</p> Source code in <code>src/holden/graphs.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Adjacency:\n    \"\"\"Returns a new graph without a subset of `contents`.\n\n    Args:\n        include: nodes or edges which should be included in the new graph.\n        exclude: nodes or edges which should not be included in the new\n            graph.\n\n    Returns:\n       Adjacency with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Node","title":"<code>Node(contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Hashable</code></p> <p>Vertex wrapper to provide hashability to any object.</p> <p>Node acts a basic wrapper for any item stored in a graph structure.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Any | None</code> <p>any stored item(s). Defaults to None.</p> <code>None</code>"},{"location":"reference/holden/#holden.Node.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/#holden.Parallel","title":"<code>Parallel(contents=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Listing</code>, <code>Directed</code>, <code>Composite</code></p> <p>Base class for a list of serial composites.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Serial]</code> <p>Listing of Serial instances. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/#holden.Parallel.contents","title":"<code>contents = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/holden/#holden.Parallel.endpoint","title":"<code>endpoint</code>  <code>property</code>","text":"<p>Returns the endpoints of the stored composite.</p>"},{"location":"reference/holden/#holden.Parallel.root","title":"<code>root</code>  <code>property</code>","text":"<p>Returns the roots of the stored composite.</p>"},{"location":"reference/holden/#holden.Parallel._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite.\n\n    Args:\n        item: node to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Parallel._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    del self.contents[item]\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Parallel._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored composite.</p> <p>Subclasses must provide their own specific methods for merging with another composite. The provided <code>merge</code> method offers all of the error checking. Subclasses just need to provide the mechanism for merging ithout worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite object to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _merge(self, item: base.Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored composite.\n\n    Subclasses must provide their own specific methods for merging with\n    another composite. The provided `merge` method offers all of the error\n    checking. Subclasses just need to provide the mechanism for merging\n    ithout worrying about validation or error-checking.\n\n    Args:\n        item: another Composite object to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'parallel',\n        raise_same_error = False)\n    for serial in other:\n        self.contents.append(serial)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Parallel._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new composite without a subset of <code>contents</code>.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. Subclasses just need to provide the mechanism for returning a subset without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel with only selected nodes and edges.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Parallel:\n    \"\"\"Returns a new composite without a subset of `contents`.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. Subclasses just need to provide the mechanism for returning a\n    subset without worrying about validation or error-checking.\n\n    Args:\n        include: nodes or edges which should be included in the new\n            composite.\n        exclude: nodes or edges which should not be included in the new\n            composite.\n\n    Returns:\n       Parallel with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.Parallel.walk","title":"<code>walk(start=None, stop=None)</code>","text":"<p>Returns all paths in graph from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>node to start paths from.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>node to stop paths.</p> <code>None</code> <p>Returns:</p> Type Description <code>Parallel</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None) -&gt; Parallel:\n    \"\"\"Returns all paths in graph from `start` to `stop`.\n\n    Args:\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    root = self.root if start is None else bunches.listify(start)\n    endpoint = self.endpoint if stop is None else self.bunches.listify(stop)\n    return traverse.walk_parallel(\n        item = self,\n        start = root,\n        stop = endpoint)\n</code></pre>"},{"location":"reference/holden/#holden.Serial","title":"<code>Serial(contents=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DictList</code>, <code>Directed</code>, <code>Composite</code></p> <p>Base class for serial composites.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Hashable]</code> <p>list of nodes. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/#holden.Serial.contents","title":"<code>contents = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/holden/#holden.Serial.endpoint","title":"<code>endpoint</code>  <code>property</code>","text":"<p>Returns the endpoints of the stored composite.</p>"},{"location":"reference/holden/#holden.Serial.root","title":"<code>root</code>  <code>property</code>","text":"<p>Returns the roots of the stored composite.</p>"},{"location":"reference/holden/#holden.Serial._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite.\n\n    Args:\n        item: node to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Serial._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    del self.contents[item]\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Serial._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored composite.</p> <p>Subclasses must provide their own specific methods for merging with another composite. The provided <code>merge</code> method offers all of the error checking. Subclasses just need to provide the mechanism for merging ithout worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite object to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _merge(self, item: base.Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored composite.\n\n    Subclasses must provide their own specific methods for merging with\n    another composite. The provided `merge` method offers all of the error\n    checking. Subclasses just need to provide the mechanism for merging\n    ithout worrying about validation or error-checking.\n\n    Args:\n        item: another Composite object to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'serial',\n        raise_same_error = False)\n    self.contents.extend(other)\n    return\n</code></pre>"},{"location":"reference/holden/#holden.Serial._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new composite without a subset of <code>contents</code>.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. Subclasses just need to provide the mechanism for returning a subset without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Serial</code> <p>Serial with only selected nodes and edges.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Serial:\n    \"\"\"Returns a new composite without a subset of `contents`.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. Subclasses just need to provide the mechanism for returning a\n    subset without worrying about validation or error-checking.\n\n    Args:\n        include: nodes or edges which should be included in the new\n            composite.\n        exclude: nodes or edges which should not be included in the new\n            composite.\n\n    Returns:\n       Serial with only selected nodes and edges.\n\n    \"\"\"\n    if include:\n        new_serial = [i for i in self.contents if i in include]\n    else:\n        new_serial = copy.deepcopy(self.contents)\n    if exclude:\n        new_serial = [i for i in self.contents if i not in exclude]\n    return self.__class__(contents = new_serial)\n</code></pre>"},{"location":"reference/holden/#holden.Serial.walk","title":"<code>walk(start=None, stop=None)</code>","text":"<p>Returns all paths in graph from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>node to start paths from.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>node to stop paths.</p> <code>None</code> <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None) -&gt; Parallel:\n    \"\"\"Returns all paths in graph from `start` to `stop`.\n\n    Args:\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        Parallel list of possible paths (each path is a list nodes) from\n            `start` to `stop`.\n\n    \"\"\"\n    if start is None:\n        start = self.root[0]\n    if stop is None:\n        stop = self.endpoint[0]\n    return traverse.walk_serial(item = self, start = start, stop = stop)\n</code></pre>"},{"location":"reference/holden/#holden.System","title":"<code>System(contents=lambda: collections.defaultdict(set)())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Adjacency</code>, <code>Directed</code>, <code>Fungible</code></p> <p>Directed graph with unweighted edges stored as an adjacency list.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, Set[Hashable]]</code> <p>keys are nodes and values are sets of nodes (or hashable representations of nodes). Defaults to a defaultdict that has a set for its value format.</p> <code>lambda: defaultdict(set)()</code>"},{"location":"reference/holden/#holden.System.contents","title":"<code>contents = dataclasses.field(default_factory=lambda: collections.defaultdict(set))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/holden/#holden.System.endpoint","title":"<code>endpoint</code>  <code>property</code>","text":"<p>Returns the endpoints of the stored composite.</p>"},{"location":"reference/holden/#holden.System.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Returns a set of all nodes in the System.</p>"},{"location":"reference/holden/#holden.System.root","title":"<code>root</code>  <code>property</code>","text":"<p>Returns the roots of the stored composite.</p>"},{"location":"reference/holden/#holden.System.append","title":"<code>append(item)</code>","text":"<p>Appends <code>item</code> to the endpoints of the stored graph.</p> <p>Appending creates an edge between every endpoint of this instance's stored graph and the every root of <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph, an adjacency list, an edge list, an adjacency matrix, or one or more nodes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is neither a Graph, Adjacency, Edges, Matrix, or Collection[Hashable] type.</p> Source code in <code>src/holden/applications.py</code> <pre><code>def append(self, item: base.Graph) -&gt; None:\n    \"\"\"Appends `item` to the endpoints of the stored graph.\n\n    Appending creates an edge between every endpoint of this instance's\n    stored graph and the every root of `item`.\n\n    Args:\n        item: another Graph, an adjacency list, an edge list, an adjacency\n            matrix, or one or more nodes.\n\n    Raises:\n        TypeError: if `item` is neither a Graph, Adjacency, Edges, Matrix,\n            or Collection[Hashable] type.\n\n    \"\"\"\n    current_endpoints = self.endpoint\n    if check.is_graph(item = item):\n        self.merge(item = item)\n        for endpoint in current_endpoints:\n            for root in workshop.get_roots_adjacency(item = item):\n                self.connect((endpoint, root))\n    elif check.is_node(item = item):\n        self.add(item = item)\n        for endpoint in current_endpoints:\n            self.connect((endpoint, item))\n    else:\n        raise TypeError('item is not a recognized graph or node type')\n    return\n</code></pre>"},{"location":"reference/holden/#holden.System.prepend","title":"<code>prepend(item)</code>","text":"<p>Prepends <code>item</code> to the roots of the stored graph.</p> <p>Prepending creates an edge between every endpoint of <code>item</code> and every root of this instance;s stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph, an adjacency list, an edge list, an adjacency matrix, or one or more nodes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is neither a System, Adjacency, Edges, Matrix, or Collection[Hashable] type.</p> Source code in <code>src/holden/applications.py</code> <pre><code>def prepend(self, item: base.Graph) -&gt; None:\n    \"\"\"Prepends `item` to the roots of the stored graph.\n\n    Prepending creates an edge between every endpoint of `item` and every\n    root of this instance;s stored graph.\n\n    Args:\n        item: another Graph, an adjacency list, an edge list, an adjacency\n            matrix, or one or more nodes.\n\n    Raises:\n        TypeError: if `item` is neither a System, Adjacency, Edges, Matrix,\n            or Collection[Hashable] type.\n\n    \"\"\"\n    current_roots = self.root\n    if check.is_graph(item = item):\n        self.merge(item = item)\n        for root in current_roots:\n            for endpoint in item.endpoint:\n                self.connect((endpoint, root))\n    elif check.is_node(item = item):\n        self.add(item = item)\n        for root in current_roots:\n            self.connect((item, root))\n    else:\n        raise TypeError('item is not a recognized graph or node type')\n    return\n</code></pre>"},{"location":"reference/holden/#holden.System.walk","title":"<code>walk(start=None, stop=None)</code>","text":"<p>Returns all paths in graph from 'start' to 'stop'.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>node to start paths from.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>node to stop paths.</p> <code>None</code> <p>Returns:</p> Type Description <code>MutableSequence[MutableSequence[Hashable]]</code> <p>A list of possible paths (each path is a list nodes) from 'start' to 'stop'.</p> Source code in <code>src/holden/applications.py</code> <pre><code>def walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None) -&gt; MutableSequence[MutableSequence[Hashable]]:\n    \"\"\"Returns all paths in graph from 'start' to 'stop'.\n\n    Args:\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from 'start' to\n            'stop'.\n\n    \"\"\"\n    roots = self.root if start is None else utilities._listify(start)\n    endpoints = self.endpoint if stop is None else utilities._listify(stop)\n    all_paths = []\n    for root in roots:\n        for end in endpoints:\n            if paths := traverse.walk_adjacency(\n                    item=self.contents, start=root, stop=end):\n                if all(isinstance(p, Hashable) for p in paths):\n                    all_paths.append(paths)\n                else:\n                    all_paths.extend(paths)\n    return all_paths\n</code></pre>"},{"location":"reference/holden/#holden.Weighted","title":"<code>Weighted(weight=1.0)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin for weighted nodes.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>float | None</code> <p>the weight of the object. Defaults to 1.0.</p> <code>1.0</code>"},{"location":"reference/holden/#holden.Weighted.weight","title":"<code>weight = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/holden/#holden.add_checker","title":"<code>add_checker(name, item)</code>","text":"<p>Adds a checker to the local namespace.</p> <p>This allows the function to be found by the 'holden.classify' function and the 'holden.Forms.classify' class method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the checker function. It needs to be in the 'is_{form}' format.</p> required <code>item</code> <code>Callable[[Graph]]</code> <p>callable checker which should have a single parameter, item which should be a base.Graph type.</p> required Source code in <code>src/holden/check.py</code> <pre><code>def add_checker(name: str, item: Callable[[base.Graph]]) -&gt; None:\n    \"\"\"Adds a checker to the local namespace.\n\n    This allows the function to be found by the 'holden.classify' function and\n    the 'holden.Forms.classify' class method.\n\n    Args:\n        name: name of the checker function. It needs to be in the 'is_{form}'\n            format.\n        item: callable checker which should have a single parameter, item which\n            should be a base.Graph type.\n\n    \"\"\"\n    globals()[name] = item\n    return\n</code></pre>"},{"location":"reference/holden/#holden.add_transformer","title":"<code>add_transformer(name, item)</code>","text":"<p>Adds a transformer to this module's namespace.</p> <p>This allows the function to be found by the <code>transform</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the transformer function. It needs to be in the <code>_TRANSFORMER</code> format.</p> required <code>item</code> <code>Callable[[Composite]]</code> <p>callable transformer which should have a single parameter, item which should be a Composite type.</p> required Source code in <code>src/holden/workshop.py</code> <pre><code>def add_transformer(name: str, item: Callable[[base.Composite]]) -&gt; None:\n    \"\"\"Adds a transformer to this module's namespace.\n\n    This allows the function to be found by the `transform` function.\n\n    Args:\n        name: name of the transformer function. It needs to be in the\n            `_TRANSFORMER` format.\n        item: callable transformer which should have a single parameter, item\n            which should be a Composite type.\n\n    \"\"\"\n    globals()[name] = item\n    return\n</code></pre>"},{"location":"reference/holden/#holden.adjacency_to_edges","title":"<code>adjacency_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Type Description <code>Edges</code> <p>Edges derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_edges(item: graphs.Adjacency) -&gt; graphs.Edges:\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges derived from `item`.\n\n    \"\"\"\n    edges = []\n    for node, connections in item.items():\n        edges.extend((node, connection) for connection in connections)\n    return tuple(edges)\n</code></pre>"},{"location":"reference/holden/#holden.adjacency_to_matrix","title":"<code>adjacency_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_matrix(item: graphs.Adjacency) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    names = list(item.keys())\n    matrix = []\n    for i in range(len(item)):\n        matrix.append([0] * len(item))\n        for j in item[i]:\n            matrix[i][j] = 1\n    return matrix, names\n</code></pre>"},{"location":"reference/holden/#holden.adjacency_to_parallel","title":"<code>adjacency_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a parallel structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to a parallel structure.</p> required <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel structure derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_parallel(item: graphs.Adjacency) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a parallel structure.\n\n    Args:\n        item: item to convert to a parallel structure.\n\n    Returns:\n        Parallel structure derived from `item`.\n\n    \"\"\"\n    roots = get_roots_adjacency(item = item)\n    endpoints = get_endpoints_adjacency(item = item)\n    all_paths = []\n    for start in roots:\n        for end in endpoints:\n            if paths := traverse.walk_adjacency(\n                    item=item, start=start, stop=end):\n                if all(isinstance(path, Hashable) for path in paths):\n                    all_paths.append(paths)\n                else:\n                    all_paths.extend(paths)\n    return all_paths\n</code></pre>"},{"location":"reference/holden/#holden.adjacency_to_serial","title":"<code>adjacency_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_serial(item: graphs.Adjacency) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    all_parallel = adjacency_to_parallel(item = item)\n    if len(all_parallel) == 1:\n        return all_parallel[0]\n    else:\n        return list(itertools.chain.from_iterable(all_parallel))\n</code></pre>"},{"location":"reference/holden/#holden.classify","title":"<code>classify(item)</code>","text":"<p>Determines which form of graph that <code>item</code> is.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>object to classify.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name of form that <code>item</code> is.</p> Source code in <code>src/holden/base.py</code> <pre><code>def classify(item: object) -&gt; str:\n    \"\"\"Determines which form of graph that `item` is.\n\n    Args:\n        item: object to classify.\n\n    Returns:\n        Name of form that `item` is.\n\n    \"\"\"\n    # Chcecks for a matching parent clas in `registry`.\n    subtype = item if inspect.isclass(item) else item.__class__\n    for name, form in Forms.registry.items():\n        if issubclass(subtype, form):\n            return name\n    # Chaecks for matching raw form using functions in the `check` module.\n    for name in Forms.registry:\n        with contextlib.suppress(AttributeError):\n            checker = getattr(check, f'is_{name}')\n            if checker(item = item):\n                return name\n    raise TypeError('The passed item is not a recognized Graph form')\n</code></pre>"},{"location":"reference/holden/#holden.edges_to_adjacency","title":"<code>edges_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_adjacency(item: graphs.Edges) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    adjacency = collections.defaultdict(set)\n    for edge_pair in item:\n        if edge_pair[0] not in adjacency:\n            adjacency[edge_pair[0]] = {edge_pair[1]}\n        else:\n            adjacency[edge_pair[0]].add(edge_pair[1])\n        if edge_pair[1] not in adjacency:\n            adjacency[edge_pair[1]] = set()\n    return adjacency\n</code></pre>"},{"location":"reference/holden/#holden.edges_to_matrix","title":"<code>edges_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_matrix(item: graphs.Edges) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.edges_to_parallel","title":"<code>edges_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a Parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to a Parallel.</p> required <p>Returns:</p> Name Type Description <code>Parallel</code> <code>Parallel</code> <p>derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_parallel(item: graphs.Edges) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a Parallel.\n\n    Args:\n        item: item to convert to a Parallel.\n\n    Returns:\n        Parallel: derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.edges_to_serial","title":"<code>edges_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_serial(item: graphs.Edges) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.get_endpoints_adjacency","title":"<code>get_endpoints_adjacency(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def get_endpoints_adjacency(item: graphs.Adjacency) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\"\"\"\n    return [k for k in item if not item[k]]\n</code></pre>"},{"location":"reference/holden/#holden.get_endpoints_edges","title":"<code>get_endpoints_edges(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>edge list object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_edges(item: graphs.Edges) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: edge list object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.get_endpoints_matrix","title":"<code>get_endpoints_matrix(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>adjacency matrix object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_matrix(item: graphs.Matrix) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: adjacency matrix object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.get_endpoints_parallel","title":"<code>get_endpoints_parallel(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>parallel object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_parallel(\n    item: composites.Parallel) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: parallel object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    return [p[-1] for p in item]\n</code></pre>"},{"location":"reference/holden/#holden.get_endpoints_serial","title":"<code>get_endpoints_serial(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>serial object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_serial(item: composites.Serial) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: serial object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    return [item[-1]]\n</code></pre>"},{"location":"reference/holden/#holden.get_roots_adjacency","title":"<code>get_roots_adjacency(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def get_roots_adjacency(item: graphs.Adjacency) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\"\"\"\n    stops = list(itertools.chain.from_iterable(item.values()))\n    return [k for k in item if k not in stops]\n</code></pre>"},{"location":"reference/holden/#holden.get_roots_edges","title":"<code>get_roots_edges(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>edge list object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_edges(item: graphs.Edges) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: edge list object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.get_roots_matrix","title":"<code>get_roots_matrix(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>adjacency matrix object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_matrix(item: graphs.Matrix) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: adjacency matrix object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.get_roots_parallel","title":"<code>get_roots_parallel(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>parallel object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_parallel(item: composites.Parallel) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: parallel object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    return [p[0] for p in item]\n</code></pre>"},{"location":"reference/holden/#holden.get_roots_serial","title":"<code>get_roots_serial(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>serial object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_serial(item: composites.Serial) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: serial object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    return [item[0]]\n</code></pre>"},{"location":"reference/holden/#holden.is_adjacency","title":"<code>is_adjacency(item)</code>","text":"<p>Returns whether <code>item</code> is an adjacency list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an adjacency list.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_adjacency(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an adjacency list.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an adjacency list.\n\n    \"\"\"\n    if isinstance(item, MutableMapping):\n        connections = list(item.values())\n        nodes = list(itertools.chain.from_iterable(item.values()))\n        return (\n            all(isinstance(e, set) for e in connections)\n            and all(is_node(item = i) for i in nodes))\n    else:\n        return False\n</code></pre>"},{"location":"reference/holden/#holden.is_composite","title":"<code>is_composite(item)</code>","text":"<p>Returns whether <code>item</code> is a composite data structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Any] | object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a composite data structure.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_composite(item: type[Any] | object) -&gt; bool:\n    \"\"\"Returns whether `item` is a composite data structure.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a composite data structure.\n\n    \"\"\"\n    methods = ['add', 'delete', 'merge', 'subset']\n    return all(inspect.ismethod(getattr(item, method)) for method in methods)\n</code></pre>"},{"location":"reference/holden/#holden.is_edge","title":"<code>is_edge(item)</code>","text":"<p>Returns whether <code>item</code> is an edge.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an edge.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_edge(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an edge.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an edge.\n\n    \"\"\"\n    return (\n        isinstance(item, Sequence)\n        and not isinstance(item, str)\n        and len(item) == 2  # noqa: PLR2004\n        and is_node(item = item[0])\n        and is_node(item = item[1]))\n</code></pre>"},{"location":"reference/holden/#holden.is_edges","title":"<code>is_edges(item)</code>","text":"<p>Returns whether <code>item</code> is an edge list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an edge list.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_edges(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an edge list.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an edge list.\n\n    \"\"\"\n    return (\n        isinstance(item, MutableSequence)\n        and all(is_edge(item = i) for i in item))\n</code></pre>"},{"location":"reference/holden/#holden.is_graph","title":"<code>is_graph(item)</code>","text":"<p>Returns whether <code>item</code> is a graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Any] | object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a graph.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_graph(item: type[Any] | object) -&gt; bool:\n    \"\"\"Returns whether `item` is a graph.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a graph.\n\n    \"\"\"\n    return (\n        is_composite(item = item)\n        and inspect.ismethod(item.connect)\n        and inspect.ismethod(item.disconnect))\n</code></pre>"},{"location":"reference/holden/#holden.is_matrix","title":"<code>is_matrix(item)</code>","text":"<p>Returns whether <code>item</code> is an adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an adjacency matrix.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_matrix(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an adjacency matrix.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an adjacency matrix.\n\n    \"\"\"\n    if isinstance(item, Sequence) and len(item) == 2:  # noqa: PLR2004\n        matrix = item[0]\n        labels = item[1]\n        connections = list(itertools.chain.from_iterable(matrix))\n        return (\n            isinstance(matrix, MutableSequence)\n            and isinstance(labels, MutableSequence)\n            and all(isinstance(i, MutableSequence) for i in matrix)\n            and all(isinstance(n, Hashable) for n in labels)\n            and all(isinstance(c, int | float) for c in connections))\n    else:\n        return False\n</code></pre>"},{"location":"reference/holden/#holden.is_node","title":"<code>is_node(item)</code>","text":"<p>Returns whether <code>item</code> is a node.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object | type[Any]</code> <p>instance or class to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a node.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_node(item: object | type[Any]) -&gt; bool:\n    \"\"\"Returns whether `item` is a node.\n\n    Args:\n        item: instance or class to test.\n\n    Returns:\n        Whether `item` is a node.\n\n    \"\"\"\n    if inspect.isclass(item):\n        return issubclass(item, Hashable)\n    else:\n        return isinstance(item, Hashable)\n</code></pre>"},{"location":"reference/holden/#holden.is_nodes","title":"<code>is_nodes(item)</code>","text":"<p>Returns whether <code>item</code> is a collection of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a collection of nodes.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_nodes(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is a collection of nodes.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a collection of nodes.\n\n    \"\"\"\n    return (\n        isinstance(item, Collection) and all(is_node(item = i) for i in item))\n</code></pre>"},{"location":"reference/holden/#holden.is_parallel","title":"<code>is_parallel(item)</code>","text":"<p>Returns whether <code>item</code> is sequence of parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a sequence of parallel.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_parallel(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is sequence of parallel.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a sequence of parallel.\n\n    \"\"\"\n    return (\n        isinstance(item, MutableSequence)\n        and all(is_serial(item = i) for i in item))\n</code></pre>"},{"location":"reference/holden/#holden.is_serial","title":"<code>is_serial(item)</code>","text":"<p>Returns whether <code>item</code> is a serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a serial.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_serial(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is a serial.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a serial.\n\n    \"\"\"\n    return (\n        isinstance(item, MutableSequence)\n        and all(is_node(item = i) for i in item)\n        and all(not isinstance(i, tuple) for i in item))\n</code></pre>"},{"location":"reference/holden/#holden.matrix_to_adjacency","title":"<code>matrix_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_adjacency(item: graphs.Matrix) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    matrix = item[0]\n    names = item[1]\n    name_mapping = dict(zip(range(len(matrix)), names, strict = False))\n    raw_adjacency = {\n        i: [j for j, adjacent in enumerate(row) if adjacent]\n        for i, row in enumerate(matrix)}\n    adjacency = collections.defaultdict(set)\n    for key, value in raw_adjacency.items():\n        new_key = name_mapping[key]\n        new_values = {name_mapping[edge] for edge in value}\n        adjacency[new_key] = new_values\n    return adjacency\n</code></pre>"},{"location":"reference/holden/#holden.matrix_to_edges","title":"<code>matrix_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Name Type Description <code>Edges</code> <code>Edges</code> <p>derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_edges(item: graphs.Matrix) -&gt; graphs.Edges:\n    # sourcery skip: for-append-to-extend\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges: derived from `item`.\n\n    \"\"\"\n    matrix = item[0]\n    labels = item[1]\n    edges = []\n    for i in enumerate(matrix):\n        for j in enumerate(matrix):\n            if matrix[i][j] &gt; 0:\n                edges.append((labels[i], labels[j]))\n    return edges\n</code></pre>"},{"location":"reference/holden/#holden.matrix_to_parallel","title":"<code>matrix_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a Parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to a Parallel.</p> required <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_parallel(item: graphs.Matrix) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a Parallel.\n\n    Args:\n        item: item to convert to a Parallel.\n\n    Returns:\n        Parallel derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.matrix_to_serial","title":"<code>matrix_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_serial(item: graphs.Matrix) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.parallel_to_adjacency","title":"<code>parallel_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_adjacency(item: composites.Parallel) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    adjacency = collections.defaultdict(set)\n    for serial in item:\n        pipe_adjacency = serial_to_adjacency(item = serial)\n        for key, value in pipe_adjacency.items():\n            if key in adjacency:\n                for inner_value in value:\n                    if inner_value not in adjacency:\n                        adjacency[key].add(inner_value)\n            else:\n                adjacency[key] = value\n    return adjacency\n</code></pre>"},{"location":"reference/holden/#holden.parallel_to_edges","title":"<code>parallel_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Type Description <code>Edges</code> <p>Edges derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_edges(item: composites.Parallel) -&gt; graphs.Edges:\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.parallel_to_matrix","title":"<code>parallel_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_matrix(item: composites.Parallel) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.parallel_to_serial","title":"<code>parallel_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_serial(item: composites.Parallel) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.serial_to_adjacency","title":"<code>serial_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_adjacency(item: composites.Serial) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    if check.is_parallel(item = item):\n        return parallel_to_adjacency(item = item)\n    if not isinstance(item, (Collection)) or isinstance(item, str):\n        item = [item]\n    adjacency = collections.defaultdict(set)\n    if len(item) == 1:\n        adjacency.update({item[0]: set()})\n    else:\n        edges = list(utilities._windowify(item, 2))\n        for edge_pair in edges:\n            if edge_pair[0] in adjacency:\n                adjacency[edge_pair[0]].add(edge_pair[1])\n            else:\n                adjacency[edge_pair[0]] = {edge_pair[1]}\n    return adjacency\n</code></pre>"},{"location":"reference/holden/#holden.serial_to_edges","title":"<code>serial_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Type Description <code>Edges</code> <p>Edges derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_edges(item: composites.Serial) -&gt; graphs.Edges:\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.serial_to_matrix","title":"<code>serial_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_matrix(item: composites.Serial) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.serial_to_parallel","title":"<code>serial_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a Parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to a Parallel.</p> required <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_parallel(item: composites.Serial) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a Parallel.\n\n    Args:\n        item: item to convert to a Parallel.\n\n    Returns:\n        Parallel derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.set_base","title":"<code>set_base(name, value)</code>","text":"<p>Sets default base class for a form of graph.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of form to set.</p> required <code>value</code> <code>Type[Graph]</code> <p>Graph subclass to use as the base type for the 'name' form.</p> required Source code in <code>src/holden/options.py</code> <pre><code>def set_base(name: str, value: type[base.Graph]) -&gt; None:\n    \"\"\"Sets default base class for a form of graph.\n\n    Args:\n        name (str): name of form to set.\n        value (Type[base.Graph]): Graph subclass to use as the base type for\n            the 'name' form.\n\n    \"\"\"\n    variable = f'(_BASE_{name.upper()})'\n    globals()[variable] = value\n    return\n</code></pre>"},{"location":"reference/holden/#holden.to_dot","title":"<code>to_dot(item, path=None, name='holden', settings=None)</code>","text":"<p>Converts 'item' to a dot format.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>item to convert to a dot format.</p> required <code>path</code> <code>str | Path | None</code> <p>path to export 'item' to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>name of 'item' to put in the dot str. Defaults to 'holden'.</p> <code>'holden'</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the dot graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in graphviz dot format.</p> Source code in <code>src/holden/export.py</code> <pre><code>def to_dot(\n    item: base.Composite,\n    path: str | pathlib.Path | None = None,\n    name: str = 'holden',\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts 'item' to a dot format.\n\n    Args:\n        item: item to convert to a dot format.\n        path: path to export 'item' to. Defaults to None.\n        name: name of 'item' to put in the dot str. Defaults to 'holden'.\n        settings: any global settings to add to the dot graph. Defaults to None.\n\n    Returns:\n        Composite object in graphviz dot format.\n\n    \"\"\"\n    edges = base.transform(\n        item = item,\n        output = 'edges',\n        raise_same_error = False)\n    if isinstance(item, traits.Directed):\n        dot = 'digraph '\n        link = _DOT_ARROW\n    else:\n        dot = 'graph '\n        link = _CONNECTOR\n    dot = dot + name + ' {\\n'\n    if settings is not None:\n        for key, value in settings.items():\n            dot = f'{dot}{key}={value};{_LINE_BREAK}'\n    for edge in edges:\n        dot = f'{dot}{edge[0]} {link} {edge[1]}{_LINE_BREAK}'\n    dot = dot + '}'\n    if path is not None:\n        _save_file(dot, path)\n    return dot\n</code></pre>"},{"location":"reference/holden/#holden.to_mermaid","title":"<code>to_mermaid(item, path=None, name='holden', settings=None)</code>","text":"<p>Converts 'item' to a mermaid format.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>item to convert to a mermaid format.</p> required <code>path</code> <code>str | Path | None</code> <p>path to export 'item' to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>name of 'item' to put in the mermaid str. Defaults to 'holden'.</p> <code>'holden'</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the mermaid graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in mermaid format.</p> Source code in <code>src/holden/export.py</code> <pre><code>def to_mermaid(\n    item: base.Composite,\n    path: str | pathlib.Path | None = None,\n    name: str = 'holden',\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts 'item' to a mermaid format.\n\n    Args:\n        item: item to convert to a mermaid format.\n        path: path to export 'item' to. Defaults to None.\n        name: name of 'item' to put in the mermaid str. Defaults to 'holden'.\n        settings: any global settings to add to the mermaid graph. Defaults to\n            None.\n\n    Returns:\n        Composite object in mermaid format.\n\n    \"\"\"\n    edges = base.transform(\n        item = item,\n        output = 'edges',\n        raise_same_error = False)\n    link = _MERMAID_ARROW if isinstance(item, traits.Directed) else _CONNECTOR\n    code = ''\n    code = _add_mermaid_settings(code, name, settings)\n    code = f'{code}flowchart LR{_LINE_BREAK}'\n    for edge in edges:\n        code = f'{code}{_INDENT}{edge[0]}({edge[0]}) {link} {edge[1]}({edge[1]}){_LINE_BREAK}'\n    if path is not None:\n        _save_file(code, path)\n    return code\n</code></pre>"},{"location":"reference/holden/#holden.transform","title":"<code>transform(item, output, *, raise_same_error=True)</code>","text":"<p>General transform function that will call appropriate transformer.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>Graph to transform.</p> required <code>output</code> <code>str</code> <p>name of form to transform <code>item</code> to.</p> required <code>raise_same_error</code> <code>bool | None</code> <p>whether to return an error if the form of <code>item</code> is the same as <code>output</code>. If True, a ValueError will be returned. If False, item will be return without any change. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the form of <code>item</code> is the same as <code>output</code> and <code>raise_same_error</code> is True.</p> <p>Returns:</p> Type Description <code>Graph</code> <p>Transformed graph.</p> Source code in <code>src/holden/base.py</code> <pre><code>def transform(\n    item: Graph,\n    output: str, *,\n    raise_same_error: bool | None = True) -&gt; Graph:\n    \"\"\"General transform function that will call appropriate transformer.\n\n    Args:\n        item: Graph to transform.\n        output: name of form to transform `item` to.\n        raise_same_error: whether to return an error if the form of `item` is\n            the same as `output`. If True, a ValueError will be returned. If\n            False, item will be return without any change. Defaults to True.\n\n    Raises:\n        ValueError: if the form of `item` is the same as `output` and\n            `raise_same_error` is True.\n\n    Returns:\n        Transformed graph.\n\n    \"\"\"\n    form = classify(item)\n    if form == output and raise_same_error:\n        raise ValueError('The passed item and output are the same type')\n    if form == output:\n        return item\n    transformer = getattr(workshop, f'{form}_to_{output}')\n    return transformer(item = item)\n</code></pre>"},{"location":"reference/holden/#holden.walk_adjacency","title":"<code>walk_adjacency(item, start, stop, path=None)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>The code here is adapted from: https://www.python.org/doc/essays/graphs/</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <code>path</code> <code>Sequence[Hashable] | None</code> <p>a path from <code>start</code> to <code>stop</code>. This is used for recursion within the function to accumulate all possible paths. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_adjacency(\n    item: graphs.Adjacency,\n    start: Hashable,\n    stop: Hashable,\n    path: Sequence[Hashable] | None = None) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    The code here is adapted from: https://www.python.org/doc/essays/graphs/\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n        path: a path from `start` to `stop`. This is used for recursion within\n            the function to accumulate all possible paths. Defaults to None.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    if path is None:\n        path = []\n    path = [*path, start]\n    if start == stop:\n        return [path]\n    if start not in item:\n        return []\n    paths = []\n    for node in item[start]:\n        if node not in path:\n            new_paths = walk_adjacency(\n                item = item,\n                start = node,\n                stop = stop,\n                path = path)\n            paths.extend(iter(new_paths))\n    return paths\n</code></pre>"},{"location":"reference/holden/#holden.walk_edges","title":"<code>walk_edges(item, start, stop, path=None)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <code>path</code> <code>Sequence[Hashable] | None</code> <p>a path from <code>start</code> to <code>stop</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_edges(\n    item: graphs.Edges,\n    start: Hashable,\n    stop: Hashable,\n    path: Sequence[Hashable] | None = None) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n        path: a path from `start` to `stop`. Defaults to None.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.walk_matrix","title":"<code>walk_matrix(item, start, stop, path=None)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <code>path</code> <code>Sequence[Hashable] | None</code> <p>a path from <code>start</code> to <code>stop</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_matrix(\n    item: graphs.Matrix,\n    start: Hashable,\n    stop: Hashable,\n    path: Sequence[Hashable] | None = None) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n        path: a path from `start` to `stop`. Defaults to None.\n\n    Returns:\n        A list of possible paths (each path is a list nodes)\n            from `start` to `stop`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/#holden.walk_parallel","title":"<code>walk_parallel(item, start, stop)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_parallel(\n    item: composites.Parallel,\n    start: Hashable,\n    stop: Hashable) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    return [walk_serial(item = p, start = start, stop = stop) for p in item]\n</code></pre>"},{"location":"reference/holden/#holden.walk_serial","title":"<code>walk_serial(item, start, stop)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <p>Returns:</p> Name Type Description <code>Sequence</code> <code>Sequence[Hashable]</code> <p>a list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_serial(\n    item: composites.Serial,\n    start: Hashable,\n    stop: Hashable) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        Sequence: a list of possible paths (each path is a list nodes) from\n            `start` to `stop`.\n\n    \"\"\"\n    index_start = item.index(start)\n    index_stop = item.index(stop)\n    if index_stop &gt; len(item):\n        path = item[index_start:]\n    else:\n        path = item[index_start:index_stop]\n    return path\n</code></pre>"},{"location":"reference/holden/applications/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> applications","text":"<p>Concrete lightweight graph data structures.</p> Contents <p>System: a directed graph with unweighted edges with an internal adjacency    list structure.</p> To Do <p>Complete Network which will use an adjacency matrix for internal storage.</p>"},{"location":"reference/holden/applications/#holden.applications.System","title":"<code>System(contents=lambda: collections.defaultdict(set)())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Adjacency</code>, <code>Directed</code>, <code>Fungible</code></p> <p>Directed graph with unweighted edges stored as an adjacency list.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, Set[Hashable]]</code> <p>keys are nodes and values are sets of nodes (or hashable representations of nodes). Defaults to a defaultdict that has a set for its value format.</p> <code>lambda: defaultdict(set)()</code>"},{"location":"reference/holden/applications/#holden.applications.System.contents","title":"<code>contents = dataclasses.field(default_factory=lambda: collections.defaultdict(set))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/holden/applications/#holden.applications.System.endpoint","title":"<code>endpoint</code>  <code>property</code>","text":"<p>Returns the endpoints of the stored composite.</p>"},{"location":"reference/holden/applications/#holden.applications.System.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Returns a set of all nodes in the System.</p>"},{"location":"reference/holden/applications/#holden.applications.System.root","title":"<code>root</code>  <code>property</code>","text":"<p>Returns the roots of the stored composite.</p>"},{"location":"reference/holden/applications/#holden.applications.System.append","title":"<code>append(item)</code>","text":"<p>Appends <code>item</code> to the endpoints of the stored graph.</p> <p>Appending creates an edge between every endpoint of this instance's stored graph and the every root of <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph, an adjacency list, an edge list, an adjacency matrix, or one or more nodes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is neither a Graph, Adjacency, Edges, Matrix, or Collection[Hashable] type.</p> Source code in <code>src/holden/applications.py</code> <pre><code>def append(self, item: base.Graph) -&gt; None:\n    \"\"\"Appends `item` to the endpoints of the stored graph.\n\n    Appending creates an edge between every endpoint of this instance's\n    stored graph and the every root of `item`.\n\n    Args:\n        item: another Graph, an adjacency list, an edge list, an adjacency\n            matrix, or one or more nodes.\n\n    Raises:\n        TypeError: if `item` is neither a Graph, Adjacency, Edges, Matrix,\n            or Collection[Hashable] type.\n\n    \"\"\"\n    current_endpoints = self.endpoint\n    if check.is_graph(item = item):\n        self.merge(item = item)\n        for endpoint in current_endpoints:\n            for root in workshop.get_roots_adjacency(item = item):\n                self.connect((endpoint, root))\n    elif check.is_node(item = item):\n        self.add(item = item)\n        for endpoint in current_endpoints:\n            self.connect((endpoint, item))\n    else:\n        raise TypeError('item is not a recognized graph or node type')\n    return\n</code></pre>"},{"location":"reference/holden/applications/#holden.applications.System.prepend","title":"<code>prepend(item)</code>","text":"<p>Prepends <code>item</code> to the roots of the stored graph.</p> <p>Prepending creates an edge between every endpoint of <code>item</code> and every root of this instance;s stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph, an adjacency list, an edge list, an adjacency matrix, or one or more nodes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is neither a System, Adjacency, Edges, Matrix, or Collection[Hashable] type.</p> Source code in <code>src/holden/applications.py</code> <pre><code>def prepend(self, item: base.Graph) -&gt; None:\n    \"\"\"Prepends `item` to the roots of the stored graph.\n\n    Prepending creates an edge between every endpoint of `item` and every\n    root of this instance;s stored graph.\n\n    Args:\n        item: another Graph, an adjacency list, an edge list, an adjacency\n            matrix, or one or more nodes.\n\n    Raises:\n        TypeError: if `item` is neither a System, Adjacency, Edges, Matrix,\n            or Collection[Hashable] type.\n\n    \"\"\"\n    current_roots = self.root\n    if check.is_graph(item = item):\n        self.merge(item = item)\n        for root in current_roots:\n            for endpoint in item.endpoint:\n                self.connect((endpoint, root))\n    elif check.is_node(item = item):\n        self.add(item = item)\n        for root in current_roots:\n            self.connect((item, root))\n    else:\n        raise TypeError('item is not a recognized graph or node type')\n    return\n</code></pre>"},{"location":"reference/holden/applications/#holden.applications.System.walk","title":"<code>walk(start=None, stop=None)</code>","text":"<p>Returns all paths in graph from 'start' to 'stop'.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>node to start paths from.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>node to stop paths.</p> <code>None</code> <p>Returns:</p> Type Description <code>MutableSequence[MutableSequence[Hashable]]</code> <p>A list of possible paths (each path is a list nodes) from 'start' to 'stop'.</p> Source code in <code>src/holden/applications.py</code> <pre><code>def walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None) -&gt; MutableSequence[MutableSequence[Hashable]]:\n    \"\"\"Returns all paths in graph from 'start' to 'stop'.\n\n    Args:\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from 'start' to\n            'stop'.\n\n    \"\"\"\n    roots = self.root if start is None else utilities._listify(start)\n    endpoints = self.endpoint if stop is None else utilities._listify(stop)\n    all_paths = []\n    for root in roots:\n        for end in endpoints:\n            if paths := traverse.walk_adjacency(\n                    item=self.contents, start=root, stop=end):\n                if all(isinstance(p, Hashable) for p in paths):\n                    all_paths.append(paths)\n                else:\n                    all_paths.extend(paths)\n    return all_paths\n</code></pre>"},{"location":"reference/holden/base/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> base","text":"<p>Base classes for composite data structures.</p> Contents <p>Forms: stores all direct subclasses of <code>Composite</code> and <code>Graph</code> and provides     convenient classification and transformation methods. Composite: base class for all composite data structures. Graph: base class for graphs. Edge: base class for an edge in a graph. Many graphs will not require edge     instances, but the class is made available for more complex graphs and     type checking. Node: wrapper for items that can be stored in a composite data structure.</p> <p>classify: returns name of the subtype a subtype of the passed item. transform: general subtype transformer that allows any base form of a     Composite or Graph to be changed to any other recognized form.</p> <p>To Do:</p>"},{"location":"reference/holden/base/#holden.base.Composite","title":"<code>Composite(contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for composite data structures.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Collection[Any] | None</code> <p>stored nodes or node labels. Subclasses should narrow the type for contents based on the internal storage format used.</p> <code>None</code>"},{"location":"reference/holden/base/#holden.base.Composite.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/base/#holden.base.Composite._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for adding a single node. The provided <code>add</code> method offers all of the error checking and the ability to add multiple nodes at once. Subclasses just need to provide the mechanism for adding a single node without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite data structure.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite data structure.\n\n    Subclasses must provide their own specific methods for adding a single\n    node. The provided `add` method offers all of the error checking and\n    the ability to add multiple nodes at once. Subclasses just need to\n    provide the mechanism for adding a single node without worrying about\n    validation or error-checking.\n\n    Args:\n        item: node to add to the stored composite data structure.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Composite._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for deleting a single node. The provided <code>delete</code> method offers all of the error checking and the ability to delete multiple nodes at once. Subclasses just need to provide the mechanism for deleting a single node without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite data structure.\n\n    Subclasses must provide their own specific methods for deleting a single\n    node. The provided `delete` method offers all of the error checking and\n    the ability to delete multiple nodes at once. Subclasses just need to\n    provide the mechanism for deleting a single node without worrying about\n    validation or error-checking.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Composite._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for merging with another composite data structure. The provided <code>merge</code> method offers all of the error checking. Subclasses just need to provide the mechanism for merging without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite object to add to the stored composite data structure.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _merge(self, item: Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored composite data structure.\n\n    Subclasses must provide their own specific methods for merging with\n    another composite data structure. The provided `merge` method offers all\n    of the error checking. Subclasses just need to provide the mechanism for\n    merging without worrying about validation or error-checking.\n\n    Args:\n        item: another Composite object to add to the stored\n            composite data structure.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Composite._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new Composite without a subset of <code>contents</code>.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. Subclasses just need to provide the mechanism for returning a subset without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite data structure.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite data structure.</p> <code>None</code> <p>Returns:</p> Type Description <code>Composite</code> <p>Graph with only selected nodes and edges.</p> Source code in <code>src/holden/base.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Composite:\n    \"\"\"Returns a new Composite without a subset of `contents`.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. Subclasses just need to provide the mechanism for returning a\n    subset without worrying about validation or error-checking.\n\n    Args:\n        include: nodes or edges which\n            should be included in the new composite data structure.\n        exclude: nodes or edges which\n            should not be included in the new composite data structure.\n\n    Returns:\n       Graph with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Composite.add","title":"<code>add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite data structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite data structure.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is not a node type.</p> <code>ValueError</code> <p>if <code>item</code> is already in the stored composite data structure.</p> Source code in <code>src/holden/base.py</code> <pre><code>def add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite data structure.\n\n    Args:\n        item: node to add to the stored composite data structure.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        TypeError: if `item` is not a node type.\n        ValueError: if `item` is already in the stored composite data\n            structure.\n\n    \"\"\"\n    if not check.is_node(item = item):\n        raise TypeError(f'{item} is not a node type')\n    if item in self.contents:\n        raise ValueError(\n            f'{item} is already in the composite data structure')\n    self._add(item, **kwargs)\n    return\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Composite.delete","title":"<code>delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite data structure.</p> <p>Subclasses must provide their own specific methods for deleting a single node. The provided <code>delete</code> method offers all of the error checking and the ability to delete multiple nodes at once. Subclasses just need to provide the mechanism for deleting a single node without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if <code>item</code> is not in <code>contents</code>.</p> <code>TypeError</code> <p>if <code>item</code> is not in <code>contents</code>.</p> Source code in <code>src/holden/base.py</code> <pre><code>def delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite data structure.\n\n    Subclasses must provide their own specific methods for deleting a single\n    node. The provided `delete` method offers all of the error checking and\n    the ability to delete multiple nodes at once. Subclasses just need to\n    provide the mechanism for deleting a single node without worrying about\n    validation or error-checking.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        KeyError: if `item` is not in `contents`.\n        TypeError: if `item` is not in `contents`.\n\n    \"\"\"\n    if not check.is_node(item = item):\n        raise TypeError(f'{item} is not a node type')\n    try:\n        self._delete(item, **kwargs)\n    except KeyError as e:\n        message = f'{item} does not exist in the composite data structure'\n        raise KeyError(message) from e\n    return\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Composite.merge","title":"<code>merge(item, **kwargs)</code>","text":"<p>Adds <code>item</code> to this Composite.</p> <p>This method is roughly equivalent to a dict.update, just adding <code>item</code> to the existing stored composite data structure while maintaining its structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite to merge with</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is not compatible composite data structure type.</p> Source code in <code>src/holden/base.py</code> <pre><code>def merge(self, item: Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Adds `item` to this Composite.\n\n    This method is roughly equivalent to a dict.update, just adding `item`\n    to the existing stored composite data structure while maintaining its\n    structure.\n\n    Args:\n        item: another Composite to merge with\n        kwargs: additional keyword arguments.\n\n    Raises:\n        TypeError: if `item` is not compatible composite data structure\n            type.\n\n    \"\"\"\n    if not check.is_composite(item = item):\n        raise TypeError(f'{item} is not a compatible type')\n    self._merge(item, **kwargs)\n    return\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Composite.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new Composite without a subset of <code>contents</code>.</p> <p>All edges will be removed that include any nodes that are not part of the new composite data structure.</p> <p>Any extra attributes that are part of a Composite (or a subclass) should be maintained in the returned composite data structure.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite data structure.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite data structure.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if include and exclude are none or if any item in include or exclude is not in the stored composite data structure.</p> <p>Returns:</p> Type Description <code>Composite</code> <p>Composite with only selected nodes and edges.</p> Source code in <code>src/holden/base.py</code> <pre><code>def subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Composite:\n    \"\"\"Returns a new Composite without a subset of `contents`.\n\n    All edges will be removed that include any nodes that are not part of\n    the new composite data structure.\n\n    Any extra attributes that are part of a Composite (or a subclass) should\n    be maintained in the returned composite data structure.\n\n    Args:\n        include: nodes or edges which should be included in the new\n            composite data structure.\n        exclude: nodes or edges which should not be included in the new\n            composite data structure.\n\n    Raises:\n        ValueError: if include and exclude are none or if any item in\n            include or exclude is not in the stored composite data\n            structure.\n\n    Returns:\n       Composite with only selected nodes and edges.\n\n    \"\"\"\n    if include is None and exclude is None:\n        raise ValueError('Either include or exclude must not be None')\n    if not all(i for i in include if i in self.contents):\n        raise ValueError(\n            'Some values in include are not in the composite data '\n            'structure')\n    if not all(i for i in exclude if i in self.contents):\n        raise ValueError(\n            'Some values in exclude are not in the composite data '\n            'structure')\n    return self._subset(include, exclude)\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Edge","title":"<code>Edge(start, stop)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Sequence</code></p> <p>Base class for an edge in a graph structure.</p> <p>Edges are not required for most of the base graph classes in holden. But they can be used by subclasses of those base classes for more complex data structures.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable</code> <p>starting point for the edge.</p> required <code>stop</code> <code>Hashable</code> <p>stopping point for the edge.</p> required"},{"location":"reference/holden/base/#holden.base.Edge.stop","title":"<code>stop</code>  <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/holden/base/#holden.base.Forms","title":"<code>Forms()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registrar</code></p> <p>Registry of composite data structures.</p> <p>Attributes:</p> Name Type Description <code>registry</code> <code>GenericDict</code> <p>stores classes and/or instances to be used in item construction. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/holden/base/#holden.base.Forms.registry","title":"<code>registry = {}</code>  <code>class-attribute</code>","text":"<p>Public Methods</p>"},{"location":"reference/holden/base/#holden.base.Forms.classify","title":"<code>classify(item)</code>  <code>classmethod</code>","text":"<p>Determines which form of composite that <code>item</code> is.</p> <p>There is no difference between this classmethod and the <code>classify</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>object to classify.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name of form that <code>item</code> is.</p> Source code in <code>src/holden/base.py</code> <pre><code>@classmethod\ndef classify(cls, item: object) -&gt; str:\n    \"\"\"Determines which form of composite that `item` is.\n\n    There is no difference between this classmethod and the `classify`\n    function.\n\n    Args:\n        item: object to classify.\n\n    Returns:\n        Name of form that `item` is.\n\n    \"\"\"\n    return classify(item)\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Forms.register","title":"<code>register(item, name=None)</code>  <code>classmethod</code>","text":"<p>Adds <code>item</code> to <code>registry</code>.</p> <p>The key assigned for storing <code>item</code> is determined using the _namify function if <code>name</code> is not passed.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Composite]</code> <p>class to register.</p> required <code>name</code> <code>str | None</code> <p>key to use for storing <code>item</code>. Defaults to None.</p> <code>None</code> Source code in <code>src/holden/base.py</code> <pre><code>@classmethod\ndef register(cls, item: type[Composite], name: str | None = None) -&gt; None:\n    \"\"\"Adds `item` to `registry`.\n\n    The key assigned for storing `item` is determined using the _namify\n    function if `name` is not passed.\n\n    Args:\n        item: class to register.\n        name: key to use for storing `item`. Defaults to None.\n\n    \"\"\"\n    name = name or utilities._namify(item)\n    cls.registry[name] = item\n    return\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Forms.transform","title":"<code>transform(item, output, *, raise_same_error=True)</code>  <code>classmethod</code>","text":"<p>General transform method that will call appropriate transformer.</p> <p>Unlike the <code>transform</code> function, this method will return a Composite wrapped in the form type stored in the Forms registry (as opposed to the raw type). So, if <code>output</code> is <code>edges</code>, this method will return an edge list in the Edges class. In contrast, the <code>transform</code> method will return the structural type of an edge list without using the Edges class. The rest of the logic is identical between the function and method.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>Composite to transform.</p> required <code>output</code> <code>str</code> <p>name of form to transform <code>item</code> to.</p> required <code>raise_same_error</code> <code>bool | None</code> <p>whether to return an error if the form of <code>item</code> is the same as <code>output</code>. If True, a ValueError will be returned. If False, item will be return without any change. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the form of <code>item</code> is the same as <code>output</code> and <code>raise_same_error</code> is True.</p> <p>Returns:</p> Type Description <code>Composite</code> <p>Transformed composite data structure.</p> Source code in <code>src/holden/base.py</code> <pre><code>@classmethod\ndef transform(\n    cls,\n    item: Composite,\n    output: str, *,\n    raise_same_error: bool | None = True) -&gt; Composite:\n    \"\"\"General transform method that will call appropriate transformer.\n\n    Unlike the `transform` function, this method will return a Composite\n    wrapped in the form type stored in the Forms registry (as opposed to the\n    raw type). So, if `output` is `edges`, this method will return an edge\n    list in the Edges class. In contrast, the `transform` method will return\n    the structural type of an edge list without using the Edges class. The\n    rest of the logic is identical between the function and method.\n\n    Args:\n        item: Composite to transform.\n        output: name of form to transform `item` to.\n        raise_same_error: whether to return an error if the form of `item`\n            is the same as `output`. If True, a ValueError will be returned.\n            If False, item will be return without any change. Defaults to\n            True.\n\n    Raises:\n        ValueError: if the form of `item` is the same as `output` and\n            `raise_same_error` is True.\n\n    Returns:\n        Transformed composite data structure.\n\n    \"\"\"\n    form = cls.classify(item)\n    if form == output and raise_same_error:\n        raise ValueError('The passed item and output are the same type')\n    if form == output:\n        return item\n    transformer = getattr(workshop, [f'{form}_to_{output}'])\n    return cls.registry[output](contents = transformer(item = item))\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Graph","title":"<code>Graph(contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Composite</code>, <code>ABC</code></p> <p>Base class for holden graphs.</p> <p>Graph adds the requirements of <code>_connect</code> and <code>_disconnect</code> methods in addition to the requirements of Composite.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Collection[Any] | None</code> <p>stored nodes, node labels, edges, or edge labels. Subclasses should narrow the type for contents based on the internal storage format used.</p> <code>None</code>"},{"location":"reference/holden/base/#holden.base.Graph.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/base/#holden.base.Graph._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Subclasses must provide their own specific methods for adding a single edge. The provided <code>connect</code> method offers all of the error checking and the ability to add multiple edges at once. Subclasses just need to provide the mechanism for adding a single edge without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _connect(self, item: Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Subclasses must provide their own specific methods for adding a single\n    edge. The provided `connect` method offers all of the error checking and\n    the ability to add multiple edges at once. Subclasses just need to\n    provide the mechanism for adding a single edge without worrying about\n    validation or error-checking.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Graph._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. The provided <code>disconnect</code> method offers all of the error checking and the ability to delete multiple edges at once. Subclasses just need to provide the mechanism for deleting a single edge without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/base.py</code> <pre><code>def _disconnect(self, item: Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. The provided `disconnect` method offers all of the error checking\n    and the ability to delete multiple edges at once. Subclasses just need\n    to provide the mechanism for deleting a single edge without worrying\n    about validation or error-checking.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Graph.connect","title":"<code>connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the ends of the item are the same or if one of the edge ends does not currently exist in the stored graph.</p> Source code in <code>src/holden/base.py</code> <pre><code>def connect(self, item: Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        ValueError: if the ends of the item are the same or if one of the\n            edge ends does not currently exist in the stored graph.\n\n    \"\"\"\n    if not check.is_edge(item = item):\n        raise TypeError(f'{item} is not an edge type')\n    if item[0] == item[1]:\n        raise ValueError(\n            'The starting point of an edge cannot be the same as the '\n            'ending point')\n    if item[0] not in self:\n        raise ValueError(f'{item[0]} is not in the graph')\n    if item[1] not in self:\n        raise ValueError(f'{item[1]} is not in the graph')\n    self._connect(item, **kwargs)\n    return\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Graph.disconnect","title":"<code>disconnect(item, *kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the edge does not exist in the stored graph.</p> Source code in <code>src/holden/base.py</code> <pre><code>def disconnect(self, item: Edge, *kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    Raises:\n        ValueError: if the edge does not exist in the stored graph.\n\n    \"\"\"\n    if not check.is_edge(item = item):\n        raise TypeError(f'{item} is not an edge type')\n    if item[0] == item[1]:\n        raise ValueError(\n            'The starting point of an edge cannot be the same as the '\n            'ending point')\n    try:\n        self._disconnect(item, **kwargs)\n    except (KeyError, ValueError) as e:\n        message = f'The edge ({item[0]}, {item[1]}) is not in the graph'\n        raise ValueError(message) from e\n    return\n</code></pre>"},{"location":"reference/holden/base/#holden.base.Node","title":"<code>Node(contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Hashable</code></p> <p>Vertex wrapper to provide hashability to any object.</p> <p>Node acts a basic wrapper for any item stored in a graph structure.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Any | None</code> <p>any stored item(s). Defaults to None.</p> <code>None</code>"},{"location":"reference/holden/base/#holden.base.Node.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/base/#holden.base.classify","title":"<code>classify(item)</code>","text":"<p>Determines which form of graph that <code>item</code> is.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>object to classify.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name of form that <code>item</code> is.</p> Source code in <code>src/holden/base.py</code> <pre><code>def classify(item: object) -&gt; str:\n    \"\"\"Determines which form of graph that `item` is.\n\n    Args:\n        item: object to classify.\n\n    Returns:\n        Name of form that `item` is.\n\n    \"\"\"\n    # Chcecks for a matching parent clas in `registry`.\n    subtype = item if inspect.isclass(item) else item.__class__\n    for name, form in Forms.registry.items():\n        if issubclass(subtype, form):\n            return name\n    # Chaecks for matching raw form using functions in the `check` module.\n    for name in Forms.registry:\n        with contextlib.suppress(AttributeError):\n            checker = getattr(check, f'is_{name}')\n            if checker(item = item):\n                return name\n    raise TypeError('The passed item is not a recognized Graph form')\n</code></pre>"},{"location":"reference/holden/base/#holden.base.transform","title":"<code>transform(item, output, *, raise_same_error=True)</code>","text":"<p>General transform function that will call appropriate transformer.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>Graph to transform.</p> required <code>output</code> <code>str</code> <p>name of form to transform <code>item</code> to.</p> required <code>raise_same_error</code> <code>bool | None</code> <p>whether to return an error if the form of <code>item</code> is the same as <code>output</code>. If True, a ValueError will be returned. If False, item will be return without any change. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the form of <code>item</code> is the same as <code>output</code> and <code>raise_same_error</code> is True.</p> <p>Returns:</p> Type Description <code>Graph</code> <p>Transformed graph.</p> Source code in <code>src/holden/base.py</code> <pre><code>def transform(\n    item: Graph,\n    output: str, *,\n    raise_same_error: bool | None = True) -&gt; Graph:\n    \"\"\"General transform function that will call appropriate transformer.\n\n    Args:\n        item: Graph to transform.\n        output: name of form to transform `item` to.\n        raise_same_error: whether to return an error if the form of `item` is\n            the same as `output`. If True, a ValueError will be returned. If\n            False, item will be return without any change. Defaults to True.\n\n    Raises:\n        ValueError: if the form of `item` is the same as `output` and\n            `raise_same_error` is True.\n\n    Returns:\n        Transformed graph.\n\n    \"\"\"\n    form = classify(item)\n    if form == output and raise_same_error:\n        raise ValueError('The passed item and output are the same type')\n    if form == output:\n        return item\n    transformer = getattr(workshop, f'{form}_to_{output}')\n    return transformer(item = item)\n</code></pre>"},{"location":"reference/holden/check/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> check","text":"<p>Functions that type check composite forms using structural subtyping.</p> Contents <p>add_checker: adds another checker to the module namespace. is_adjacency: returns whether the passed item is an adjacency list. is_edge: returns whether the passed item is an edge. is_edges: returns whether the passed item is an edge list. is_graph: returns whether the passed item is a graph. is_matrix: returns whether the passed item is an adjacency matrix. is_node: returns whether the passed item is a node. is_nodes: returns whether the passed item is a collection of nodes. is_parallel: returns whether the passed item is a list of serials. is_serial: returns whether the passed item is a serial list.</p> <p>To Do:</p>"},{"location":"reference/holden/check/#holden.check.add_checker","title":"<code>add_checker(name, item)</code>","text":"<p>Adds a checker to the local namespace.</p> <p>This allows the function to be found by the 'holden.classify' function and the 'holden.Forms.classify' class method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the checker function. It needs to be in the 'is_{form}' format.</p> required <code>item</code> <code>Callable[[Graph]]</code> <p>callable checker which should have a single parameter, item which should be a base.Graph type.</p> required Source code in <code>src/holden/check.py</code> <pre><code>def add_checker(name: str, item: Callable[[base.Graph]]) -&gt; None:\n    \"\"\"Adds a checker to the local namespace.\n\n    This allows the function to be found by the 'holden.classify' function and\n    the 'holden.Forms.classify' class method.\n\n    Args:\n        name: name of the checker function. It needs to be in the 'is_{form}'\n            format.\n        item: callable checker which should have a single parameter, item which\n            should be a base.Graph type.\n\n    \"\"\"\n    globals()[name] = item\n    return\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_adjacency","title":"<code>is_adjacency(item)</code>","text":"<p>Returns whether <code>item</code> is an adjacency list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an adjacency list.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_adjacency(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an adjacency list.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an adjacency list.\n\n    \"\"\"\n    if isinstance(item, MutableMapping):\n        connections = list(item.values())\n        nodes = list(itertools.chain.from_iterable(item.values()))\n        return (\n            all(isinstance(e, set) for e in connections)\n            and all(is_node(item = i) for i in nodes))\n    else:\n        return False\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_composite","title":"<code>is_composite(item)</code>","text":"<p>Returns whether <code>item</code> is a composite data structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Any] | object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a composite data structure.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_composite(item: type[Any] | object) -&gt; bool:\n    \"\"\"Returns whether `item` is a composite data structure.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a composite data structure.\n\n    \"\"\"\n    methods = ['add', 'delete', 'merge', 'subset']\n    return all(inspect.ismethod(getattr(item, method)) for method in methods)\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_edge","title":"<code>is_edge(item)</code>","text":"<p>Returns whether <code>item</code> is an edge.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an edge.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_edge(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an edge.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an edge.\n\n    \"\"\"\n    return (\n        isinstance(item, Sequence)\n        and not isinstance(item, str)\n        and len(item) == 2  # noqa: PLR2004\n        and is_node(item = item[0])\n        and is_node(item = item[1]))\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_edges","title":"<code>is_edges(item)</code>","text":"<p>Returns whether <code>item</code> is an edge list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an edge list.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_edges(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an edge list.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an edge list.\n\n    \"\"\"\n    return (\n        isinstance(item, MutableSequence)\n        and all(is_edge(item = i) for i in item))\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_graph","title":"<code>is_graph(item)</code>","text":"<p>Returns whether <code>item</code> is a graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Any] | object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a graph.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_graph(item: type[Any] | object) -&gt; bool:\n    \"\"\"Returns whether `item` is a graph.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a graph.\n\n    \"\"\"\n    return (\n        is_composite(item = item)\n        and inspect.ismethod(item.connect)\n        and inspect.ismethod(item.disconnect))\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_matrix","title":"<code>is_matrix(item)</code>","text":"<p>Returns whether <code>item</code> is an adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an adjacency matrix.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_matrix(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is an adjacency matrix.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is an adjacency matrix.\n\n    \"\"\"\n    if isinstance(item, Sequence) and len(item) == 2:  # noqa: PLR2004\n        matrix = item[0]\n        labels = item[1]\n        connections = list(itertools.chain.from_iterable(matrix))\n        return (\n            isinstance(matrix, MutableSequence)\n            and isinstance(labels, MutableSequence)\n            and all(isinstance(i, MutableSequence) for i in matrix)\n            and all(isinstance(n, Hashable) for n in labels)\n            and all(isinstance(c, int | float) for c in connections))\n    else:\n        return False\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_node","title":"<code>is_node(item)</code>","text":"<p>Returns whether <code>item</code> is a node.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object | type[Any]</code> <p>instance or class to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a node.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_node(item: object | type[Any]) -&gt; bool:\n    \"\"\"Returns whether `item` is a node.\n\n    Args:\n        item: instance or class to test.\n\n    Returns:\n        Whether `item` is a node.\n\n    \"\"\"\n    if inspect.isclass(item):\n        return issubclass(item, Hashable)\n    else:\n        return isinstance(item, Hashable)\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_nodes","title":"<code>is_nodes(item)</code>","text":"<p>Returns whether <code>item</code> is a collection of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a collection of nodes.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_nodes(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is a collection of nodes.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a collection of nodes.\n\n    \"\"\"\n    return (\n        isinstance(item, Collection) and all(is_node(item = i) for i in item))\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_parallel","title":"<code>is_parallel(item)</code>","text":"<p>Returns whether <code>item</code> is sequence of parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a sequence of parallel.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_parallel(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is sequence of parallel.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a sequence of parallel.\n\n    \"\"\"\n    return (\n        isinstance(item, MutableSequence)\n        and all(is_serial(item = i) for i in item))\n</code></pre>"},{"location":"reference/holden/check/#holden.check.is_serial","title":"<code>is_serial(item)</code>","text":"<p>Returns whether <code>item</code> is a serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a serial.</p> Source code in <code>src/holden/check.py</code> <pre><code>def is_serial(item: object) -&gt; bool:\n    \"\"\"Returns whether `item` is a serial.\n\n    Args:\n        item: instance to test.\n\n    Returns:\n        Whether `item` is a serial.\n\n    \"\"\"\n    return (\n        isinstance(item, MutableSequence)\n        and all(is_node(item = i) for i in item)\n        and all(not isinstance(i, tuple) for i in item))\n</code></pre>"},{"location":"reference/holden/composites/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> composites","text":"<p>Base types of other composite data structures.</p> Contents <p>Parallel: <code>list</code>-like class containing Serial instances. Serial: <code>list</code>-like class containing nodes.</p> To Do <p>Complete Tree class and related functions</p>"},{"location":"reference/holden/composites/#holden.composites.Parallel","title":"<code>Parallel(contents=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Listing</code>, <code>Directed</code>, <code>Composite</code></p> <p>Base class for a list of serial composites.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Serial]</code> <p>Listing of Serial instances. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/composites/#holden.composites.Parallel.contents","title":"<code>contents = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/holden/composites/#holden.composites.Parallel.endpoint","title":"<code>endpoint</code>  <code>property</code>","text":"<p>Returns the endpoints of the stored composite.</p>"},{"location":"reference/holden/composites/#holden.composites.Parallel.root","title":"<code>root</code>  <code>property</code>","text":"<p>Returns the roots of the stored composite.</p>"},{"location":"reference/holden/composites/#holden.composites.Parallel._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite.\n\n    Args:\n        item: node to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Parallel._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    del self.contents[item]\n    return\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Parallel._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored composite.</p> <p>Subclasses must provide their own specific methods for merging with another composite. The provided <code>merge</code> method offers all of the error checking. Subclasses just need to provide the mechanism for merging ithout worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite object to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _merge(self, item: base.Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored composite.\n\n    Subclasses must provide their own specific methods for merging with\n    another composite. The provided `merge` method offers all of the error\n    checking. Subclasses just need to provide the mechanism for merging\n    ithout worrying about validation or error-checking.\n\n    Args:\n        item: another Composite object to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'parallel',\n        raise_same_error = False)\n    for serial in other:\n        self.contents.append(serial)\n    return\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Parallel._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new composite without a subset of <code>contents</code>.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. Subclasses just need to provide the mechanism for returning a subset without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel with only selected nodes and edges.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Parallel:\n    \"\"\"Returns a new composite without a subset of `contents`.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. Subclasses just need to provide the mechanism for returning a\n    subset without worrying about validation or error-checking.\n\n    Args:\n        include: nodes or edges which should be included in the new\n            composite.\n        exclude: nodes or edges which should not be included in the new\n            composite.\n\n    Returns:\n       Parallel with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Parallel.walk","title":"<code>walk(start=None, stop=None)</code>","text":"<p>Returns all paths in graph from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>node to start paths from.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>node to stop paths.</p> <code>None</code> <p>Returns:</p> Type Description <code>Parallel</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None) -&gt; Parallel:\n    \"\"\"Returns all paths in graph from `start` to `stop`.\n\n    Args:\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    root = self.root if start is None else bunches.listify(start)\n    endpoint = self.endpoint if stop is None else self.bunches.listify(stop)\n    return traverse.walk_parallel(\n        item = self,\n        start = root,\n        stop = endpoint)\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Serial","title":"<code>Serial(contents=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DictList</code>, <code>Directed</code>, <code>Composite</code></p> <p>Base class for serial composites.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Hashable]</code> <p>list of nodes. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/composites/#holden.composites.Serial.contents","title":"<code>contents = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/holden/composites/#holden.composites.Serial.endpoint","title":"<code>endpoint</code>  <code>property</code>","text":"<p>Returns the endpoints of the stored composite.</p>"},{"location":"reference/holden/composites/#holden.composites.Serial.root","title":"<code>root</code>  <code>property</code>","text":"<p>Returns the roots of the stored composite.</p>"},{"location":"reference/holden/composites/#holden.composites.Serial._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored composite.\n\n    Args:\n        item: node to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Serial._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored composite.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    del self.contents[item]\n    return\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Serial._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored composite.</p> <p>Subclasses must provide their own specific methods for merging with another composite. The provided <code>merge</code> method offers all of the error checking. Subclasses just need to provide the mechanism for merging ithout worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>another Composite object to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/composites.py</code> <pre><code>def _merge(self, item: base.Composite, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored composite.\n\n    Subclasses must provide their own specific methods for merging with\n    another composite. The provided `merge` method offers all of the error\n    checking. Subclasses just need to provide the mechanism for merging\n    ithout worrying about validation or error-checking.\n\n    Args:\n        item: another Composite object to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'serial',\n        raise_same_error = False)\n    self.contents.extend(other)\n    return\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Serial._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new composite without a subset of <code>contents</code>.</p> <p>Subclasses must provide their own specific methods for deleting a single edge. Subclasses just need to provide the mechanism for returning a subset without worrying about validation or error-checking.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new composite.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new composite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Serial</code> <p>Serial with only selected nodes and edges.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Serial:\n    \"\"\"Returns a new composite without a subset of `contents`.\n\n    Subclasses must provide their own specific methods for deleting a single\n    edge. Subclasses just need to provide the mechanism for returning a\n    subset without worrying about validation or error-checking.\n\n    Args:\n        include: nodes or edges which should be included in the new\n            composite.\n        exclude: nodes or edges which should not be included in the new\n            composite.\n\n    Returns:\n       Serial with only selected nodes and edges.\n\n    \"\"\"\n    if include:\n        new_serial = [i for i in self.contents if i in include]\n    else:\n        new_serial = copy.deepcopy(self.contents)\n    if exclude:\n        new_serial = [i for i in self.contents if i not in exclude]\n    return self.__class__(contents = new_serial)\n</code></pre>"},{"location":"reference/holden/composites/#holden.composites.Serial.walk","title":"<code>walk(start=None, stop=None)</code>","text":"<p>Returns all paths in graph from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>node to start paths from.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>node to stop paths.</p> <code>None</code> <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/composites.py</code> <pre><code>def walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None) -&gt; Parallel:\n    \"\"\"Returns all paths in graph from `start` to `stop`.\n\n    Args:\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        Parallel list of possible paths (each path is a list nodes) from\n            `start` to `stop`.\n\n    \"\"\"\n    if start is None:\n        start = self.root[0]\n    if stop is None:\n        stop = self.endpoint[0]\n    return traverse.walk_serial(item = self, start = start, stop = stop)\n</code></pre>"},{"location":"reference/holden/export/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> export","text":"<p>Functions to export composite data structures to other formats.</p> Contents <p>to_dot: exports a composite object to a dot (Graphviz) file. to_mermaid: exports a composite object to a mermaid file.</p> To Do <p>Add different shapes to mermaid flowchart. Add excalidraw support.</p>"},{"location":"reference/holden/export/#holden.export._add_mermaid_settings","title":"<code>_add_mermaid_settings(code, name, settings)</code>","text":"<p>Adds mermaid settings to <code>code</code>.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>description</p> required <code>name</code> <code>str</code> <p>title of flowchart.</p> required <code>settings</code> <code>dict[str, Any]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>src/holden/export.py</code> <pre><code>def _add_mermaid_settings(\n    code: str,\n    name: str,\n    settings: dict[str, Any] | None) -&gt; str:\n    \"\"\"Adds mermaid settings to `code`.\n\n    Args:\n        code (str): _description_\n        name: title of flowchart.\n        settings (dict[str, Any]): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    code = f'{_MERMAID_FRONTMATTER}{_LINE_BREAK}'\n    code = f'{code}title: {name}{_LINE_BREAK}'\n    if settings is not None:\n        code = f'{code}config:{_LINE_BREAK}'\n        for key, value in settings.items():\n            code = {f'{code}{_YAML_INDENT}{key}: {value}{_LINE_BREAK}'}\n    return f'{code}{_MERMAID_FRONTMATTER}{_LINE_BREAK}'\n</code></pre>"},{"location":"reference/holden/export/#holden.export._save_file","title":"<code>_save_file(item, path)</code>","text":"<p>Saves file to disk.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p><code>str</code> item to save to disk.</p> required <code>path</code> <code>Path | str</code> <p>path to save <code>item</code> to.</p> required Source code in <code>src/holden/export.py</code> <pre><code>def _save_file(item: str, path: pathlib.Path | str) -&gt; None:\n    \"\"\"Saves file to disk.\n\n    Args:\n        item: `str` item to save to disk.\n        path: path to save `item` to.\n\n    \"\"\"\n    path = utilities._pathlibify(path)\n    with open(path, 'w') as a_file:\n        a_file.write(item)\n    a_file.close()\n    return\n</code></pre>"},{"location":"reference/holden/export/#holden.export.to_dot","title":"<code>to_dot(item, path=None, name='holden', settings=None)</code>","text":"<p>Converts 'item' to a dot format.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>item to convert to a dot format.</p> required <code>path</code> <code>str | Path | None</code> <p>path to export 'item' to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>name of 'item' to put in the dot str. Defaults to 'holden'.</p> <code>'holden'</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the dot graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in graphviz dot format.</p> Source code in <code>src/holden/export.py</code> <pre><code>def to_dot(\n    item: base.Composite,\n    path: str | pathlib.Path | None = None,\n    name: str = 'holden',\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts 'item' to a dot format.\n\n    Args:\n        item: item to convert to a dot format.\n        path: path to export 'item' to. Defaults to None.\n        name: name of 'item' to put in the dot str. Defaults to 'holden'.\n        settings: any global settings to add to the dot graph. Defaults to None.\n\n    Returns:\n        Composite object in graphviz dot format.\n\n    \"\"\"\n    edges = base.transform(\n        item = item,\n        output = 'edges',\n        raise_same_error = False)\n    if isinstance(item, traits.Directed):\n        dot = 'digraph '\n        link = _DOT_ARROW\n    else:\n        dot = 'graph '\n        link = _CONNECTOR\n    dot = dot + name + ' {\\n'\n    if settings is not None:\n        for key, value in settings.items():\n            dot = f'{dot}{key}={value};{_LINE_BREAK}'\n    for edge in edges:\n        dot = f'{dot}{edge[0]} {link} {edge[1]}{_LINE_BREAK}'\n    dot = dot + '}'\n    if path is not None:\n        _save_file(dot, path)\n    return dot\n</code></pre>"},{"location":"reference/holden/export/#holden.export.to_mermaid","title":"<code>to_mermaid(item, path=None, name='holden', settings=None)</code>","text":"<p>Converts 'item' to a mermaid format.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Composite</code> <p>item to convert to a mermaid format.</p> required <code>path</code> <code>str | Path | None</code> <p>path to export 'item' to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>name of 'item' to put in the mermaid str. Defaults to 'holden'.</p> <code>'holden'</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the mermaid graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in mermaid format.</p> Source code in <code>src/holden/export.py</code> <pre><code>def to_mermaid(\n    item: base.Composite,\n    path: str | pathlib.Path | None = None,\n    name: str = 'holden',\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts 'item' to a mermaid format.\n\n    Args:\n        item: item to convert to a mermaid format.\n        path: path to export 'item' to. Defaults to None.\n        name: name of 'item' to put in the mermaid str. Defaults to 'holden'.\n        settings: any global settings to add to the mermaid graph. Defaults to\n            None.\n\n    Returns:\n        Composite object in mermaid format.\n\n    \"\"\"\n    edges = base.transform(\n        item = item,\n        output = 'edges',\n        raise_same_error = False)\n    link = _MERMAID_ARROW if isinstance(item, traits.Directed) else _CONNECTOR\n    code = ''\n    code = _add_mermaid_settings(code, name, settings)\n    code = f'{code}flowchart LR{_LINE_BREAK}'\n    for edge in edges:\n        code = f'{code}{_INDENT}{edge[0]}({edge[0]}) {link} {edge[1]}({edge[1]}){_LINE_BREAK}'\n    if path is not None:\n        _save_file(code, path)\n    return code\n</code></pre>"},{"location":"reference/holden/graphs/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> graphs","text":"<p>Graphs with different internal storage formats.</p> Contents <p>Adjacency: a graph stored as an adjacency list. Edges: a graph stored as an edge list. Matrix: a graph stored as an adjacency matrix.</p> To Do <p>Add methods that currently raise NotImplementedError</p>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency","title":"<code>Adjacency(contents=lambda: collections.defaultdict(set)())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Graph</code>, <code>Dictionary</code></p> <p>Base class for adjacency-list graphs.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, set[Hashable]]</code> <p>keys are hashable representations of nodes. Values are the nodes to which the key node are connected. In a directed graph, the key node is assumed to come before the value node in order. Defaults to a defaultdict that has a set for its value type.</p> <code>lambda: defaultdict(set)()</code>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency.contents","title":"<code>contents = dataclasses.field(default_factory=lambda: collections.defaultdict(set))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private Methods</p>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds node to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _add(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Adds node to the stored graph.\n\n    Args:\n        item: node to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents[item] = set()\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _connect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents[item[0]].add(item[1])\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Deletes node from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>node to delete from <code>contents</code>.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _delete(self, item: Hashable, **kwargs: Any) -&gt; None:\n    \"\"\"Deletes node from the stored graph.\n\n    Args:\n        item: node to delete from `contents`.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    del self.contents[item]\n    self.contents = {k: v.remove(item) for k, v in self.contents.items()}\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _disconnect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents[item[0]].remove(item[1])\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines 'item' with the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph object to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _merge(self, item: base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Combines 'item' with the stored graph.\n\n    Args:\n        item: another Graph object to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'adjacency',\n        raise_same_error = False)\n    for node, edges in other.items():\n        if node in self:\n            self[node].update(edges)\n        else:\n            self[node] = edges\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Adjacency._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new graph without a subset of <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Union[Hashable, Sequence[Hashable]]</code> <p>nodes or edges which should be included in the new graph.</p> <code>None</code> <code>exclude</code> <code>Union[Hashable, Sequence[Hashable]]</code> <p>nodes or edges which should not be included in the new graph.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Adjacency</code> <code>Adjacency</code> <p>with only selected nodes and edges.</p> Source code in <code>src/holden/graphs.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Adjacency:\n    \"\"\"Returns a new graph without a subset of `contents`.\n\n    Args:\n        include (Union[Hashable, Sequence[Hashable]]): nodes or edges which\n            should be included in the new graph.\n        exclude (Union[Hashable, Sequence[Hashable]]): nodes or edges which\n            should not be included in the new graph.\n\n    Returns:\n       Adjacency: with only selected nodes and edges.\n\n    \"\"\"\n    excludables = [\n        k for k in self.contents if k not in include] if include else []\n    excludables.extend([i for i in self.contents if i in exclude])\n    new_graph = copy.deepcopy(self)\n    for node in utilities._iterify(excludables):\n        new_graph.delete(node = node)\n    return new_graph\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Edges","title":"<code>Edges(contents=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Graph</code>, <code>Listing</code></p> <p>Base class for edge-list graphs.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Edge]</code> <p>Listing of edges. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/graphs/#holden.graphs.Edges.contents","title":"<code>contents = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private Methods</p>"},{"location":"reference/holden/graphs/#holden.graphs.Edges._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _add(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Edges._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _connect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.append(item)\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Edges._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _delete(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.remove(item)\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Edges._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _disconnect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    self.contents.remove(item)\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Edges._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines 'item' with the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph object to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _merge(self, item: base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Combines 'item' with the stored graph.\n\n    Args:\n        item: another Graph object to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'edges',\n        raise_same_error = False)\n    self.contents.extend(other)\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Edges._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new graph without a subset of <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new graph.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency with only selected nodes and edges.</p> Source code in <code>src/holden/graphs.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Adjacency:\n    \"\"\"Returns a new graph without a subset of `contents`.\n\n    Args:\n        include: nodes or edges which should be included in the new graph.\n        exclude: nodes or edges which should not be included in the new\n            graph.\n\n    Returns:\n       Adjacency with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix","title":"<code>Matrix(contents=list(), labels=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Graph</code>, <code>Listing</code></p> <p>Base class for adjacency-matrix graphs.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[MutableSequence[int]]</code> <p>a list of list of integers indicating edges between nodes in the matrix. Defaults to an empty list.</p> <code>list()</code> <code>labels</code> <code>MutableSequence[Hashable]</code> <p>names of nodes in the matrix. Defaults to an empty list.</p> <code>list()</code>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix.labels","title":"<code>labels = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private Methods</p>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix._add","title":"<code>_add(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _add(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix._connect","title":"<code>_connect(item, **kwargs)</code>","text":"<p>Adds edge to the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _connect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Adds edge to the stored graph.\n\n    Args:\n        item: edge to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix._delete","title":"<code>_delete(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _delete(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix._disconnect","title":"<code>_disconnect(item, **kwargs)</code>","text":"<p>Removes edge from the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edge</code> <p>edge to delete from the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _disconnect(self, item: base.Edge, **kwargs: Any) -&gt; None:\n    \"\"\"Removes edge from the stored graph.\n\n    Args:\n        item: edge to delete from the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix._merge","title":"<code>_merge(item, **kwargs)</code>","text":"<p>Combines <code>item</code> with the stored graph.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Graph</code> <p>another Graph object to add to the stored graph.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/graphs.py</code> <pre><code>def _merge(self, item: base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Combines `item` with the stored graph.\n\n    Args:\n        item: another Graph object to add to the stored graph.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n    other = base.transform(\n        item = item,\n        output = 'matrix',\n        raise_same_error = False)\n    new_matrix = other[0]\n    length = len(self.contents)\n    for row in enumerate(new_matrix):\n        for column in enumerate(row):\n            self.contents[row + length][column + length] = (\n                new_matrix[row][column])\n    self.labels.extend(other[1])\n    return\n</code></pre>"},{"location":"reference/holden/graphs/#holden.graphs.Matrix._subset","title":"<code>_subset(include=None, exclude=None)</code>","text":"<p>Returns a new graph without a subset of <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should be included in the new graph.</p> <code>None</code> <code>exclude</code> <code>Hashable | Sequence[Hashable]</code> <p>nodes or edges which should not be included in the new graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency with only selected nodes and edges.</p> Source code in <code>src/holden/graphs.py</code> <pre><code>def _subset(\n    self,\n    include: Hashable | Sequence[Hashable] = None,\n    exclude: Hashable | Sequence[Hashable] = None) -&gt; Adjacency:\n    \"\"\"Returns a new graph without a subset of `contents`.\n\n    Args:\n        include: nodes or edges which should be included in the new graph.\n        exclude: nodes or edges which should not be included in the new\n            graph.\n\n    Returns:\n       Adjacency with only selected nodes and edges.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/options/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> options","text":"<p>Settings for default classes for each graph form.</p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/holden/options/#holden.options.set_base","title":"<code>set_base(name, value)</code>","text":"<p>Sets default base class for a form of graph.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of form to set.</p> required <code>value</code> <code>Type[Graph]</code> <p>Graph subclass to use as the base type for the 'name' form.</p> required Source code in <code>src/holden/options.py</code> <pre><code>def set_base(name: str, value: type[base.Graph]) -&gt; None:\n    \"\"\"Sets default base class for a form of graph.\n\n    Args:\n        name (str): name of form to set.\n        value (Type[base.Graph]): Graph subclass to use as the base type for\n            the 'name' form.\n\n    \"\"\"\n    variable = f'(_BASE_{name.upper()})'\n    globals()[variable] = value\n    return\n</code></pre>"},{"location":"reference/holden/report/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> report","text":"<p>Inspection tools for composite data structures.</p> Contents <p>get_endpoints_adjacency: returns endpoint(s) for an adjacency list. get_roots_adjacency: returns root(s) for an adjacency list. get_endpoints_edges: returns endpoint(s) for an edge list. get_roots_edges: returns root(s) for an edge list. get_endpoints_matrix: returns endpoint(s) for an adjacency matrix. get_roots_matrix: returns root(s) for an adjacency matrix.</p> To Do <p>Implement remaining functions.</p>"},{"location":"reference/holden/report/#holden.report.get_endpoints_adjacency","title":"<code>get_endpoints_adjacency(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>adjacency list object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_adjacency(\n    item: graphs.Adjacency) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: adjacency list object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    return [k for k in item if not item[k]]\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_endpoints_edges","title":"<code>get_endpoints_edges(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>edge list object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_edges(item: graphs.Edges) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: edge list object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_endpoints_matrix","title":"<code>get_endpoints_matrix(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>adjacency matrix object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_matrix(item: graphs.Matrix) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: adjacency matrix object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_endpoints_parallel","title":"<code>get_endpoints_parallel(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>parallel object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_parallel(\n    item: composites.Parallel) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: parallel object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    return [p[-1] for p in item]\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_endpoints_serial","title":"<code>get_endpoints_serial(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>serial object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of endpoints.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_endpoints_serial(item: composites.Serial) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\n\n    Args:\n        item: serial object to examine.\n\n    Returns:\n        list of endpoints.\n\n    \"\"\"\n    return [item[-1]]\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_roots_adjacency","title":"<code>get_roots_adjacency(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>adjacency list object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_adjacency(item: graphs.Adjacency) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: adjacency list object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    stops = list(itertools.chain.from_iterable(item.values()))\n    return [k for k in item if k not in stops]\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_roots_edges","title":"<code>get_roots_edges(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>edge list object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_edges(item: graphs.Edges) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: edge list object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_roots_matrix","title":"<code>get_roots_matrix(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>adjacency matrix object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_matrix(item: graphs.Matrix) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: adjacency matrix object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_roots_parallel","title":"<code>get_roots_parallel(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>parallel object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_parallel(item: composites.Parallel) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: parallel object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    return [p[0] for p in item]\n</code></pre>"},{"location":"reference/holden/report/#holden.report.get_roots_serial","title":"<code>get_roots_serial(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>serial object to examine.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Hashable]</code> <p>list of roots.</p> Source code in <code>src/holden/report.py</code> <pre><code>def get_roots_serial(item: composites.Serial) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\n\n    Args:\n        item: serial object to examine.\n\n    Returns:\n        list of roots.\n\n    \"\"\"\n    return [item[0]]\n</code></pre>"},{"location":"reference/holden/traits/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> traits","text":"<p>Characteristics of graphs, edges, and nodes.</p> Contents <p>Directed: a directed graph with unweighted edges. Exportable: mixin to allow exporting a graph to file. Fungible: mixin supporting conversion to other composite objects. Labeled: mixin to add a name attribute.</p> <p>To Do:</p>"},{"location":"reference/holden/traits/#holden.traits--storage","title":"Storage:","text":"<p>Weighted: mixin to add a weight attribute to an edge.</p>"},{"location":"reference/holden/traits/#holden.traits.Directed","title":"<code>Directed(contents)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for directed graph data structures.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Collection[Any]</code> <p>stored collection of nodes and/or edges.</p> required"},{"location":"reference/holden/traits/#holden.traits.Directed.contents","title":"<code>contents</code>  <code>instance-attribute</code>","text":"<p>Required Subclass Properties</p>"},{"location":"reference/holden/traits/#holden.traits.Directed.endpoint","title":"<code>endpoint</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns the endpoint(s) of the stored composite.</p>"},{"location":"reference/holden/traits/#holden.traits.Directed.root","title":"<code>root</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns the root(s) of the stored composite.</p>"},{"location":"reference/holden/traits/#holden.traits.Directed.append","title":"<code>append(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Appends <code>item</code> to the endpoint(s) of the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable | Graph</code> <p>a Node or Graph to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/traits.py</code> <pre><code>@abc.abstractmethod\ndef append(self, item: Hashable | base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Appends `item` to the endpoint(s) of the stored composite.\n\n    Args:\n        item: a Node or Graph to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Directed.prepend","title":"<code>prepend(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Prepends <code>item</code> to the root(s) of the stored composite.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable | Graph</code> <p>a Node or Graph to add to the stored composite.</p> required <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> Source code in <code>src/holden/traits.py</code> <pre><code>@abc.abstractmethod\ndef prepend(self, item: Hashable | base.Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Prepends `item` to the root(s) of the stored composite.\n\n    Args:\n        item: a Node or Graph to add to the stored composite.\n        kwargs: additional keyword arguments.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Directed.walk","title":"<code>walk(start=None, stop=None, path=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns path in the stored composite from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Hashable | None</code> <p>Node to start paths from. Defaults to None. If it is None, <code>start</code> will be assigned to <code>stop</code>.</p> <code>None</code> <code>stop</code> <code>Hashable | None</code> <p>Node to stop paths at. Defaults to None. If it is None, <code>stop</code> will be assigned to <code>endpoint</code>.</p> <code>None</code> <code>path</code> <code>Path | None</code> <p>a path from <code>start</code> to <code>stop</code>. Defaults to None. This parameter is used for recursively determining a path.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path(s) through the graph.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@abc.abstractmethod\ndef walk(\n    self,\n    start: Hashable | None = None,\n    stop: Hashable | None = None,\n    path: base.Path | None = None,\n    **kwargs: Any) -&gt; base.Path:\n    \"\"\"Returns path in the stored composite from `start` to `stop`.\n\n    Args:\n        start: Node to start paths from. Defaults to None. If it is None,\n            `start` will be assigned to `stop`.\n        stop: Node to stop paths at. Defaults to None. If it is None,\n            `stop` will be assigned to `endpoint`.\n        path: a path from `start` to `stop`. Defaults to None. This\n            parameter is used for recursively determining a path.\n        kwargs: additional keyword arguments.\n\n    Returns:\n        Path(s) through the graph.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Exportable","title":"<code>Exportable()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin for exporting graphs to other formats.</p>"},{"location":"reference/holden/traits/#holden.traits.Exportable.to_dot","title":"<code>to_dot(path=None, name=None, settings=None)</code>","text":"<p>Converts the stored composite to a dot format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>path to export to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>name to put in the dot str. Defaults to None.</p> <code>None</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the dot graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in graphviz dot format.</p> Source code in <code>src/holden/traits.py</code> <pre><code>def to_dot(\n    self,\n    path: str | pathlib.Path | None = None,\n    name: str | None = None,\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts the stored composite to a dot format.\n\n    Args:\n        path: path to export to. Defaults to None.\n        name: name to put in the dot str. Defaults to None.\n        settings: any global settings to add to the dot graph. Defaults to\n            None.\n\n    Returns:\n        Composite object in graphviz dot format.\n\n    \"\"\"\n    name = name or utilities._namify(self)\n    return export.to_dot(\n        item = self,\n        path = path,\n        name = name,\n        settings = settings)\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Exportable.to_mermaid","title":"<code>to_mermaid(path=None, name=None, settings=None)</code>","text":"<p>Converts the stored composite to a mermaid format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>path to export to. Defaults to None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>name to put in the mermaid str. Defaults to None.</p> <code>None</code> <code>settings</code> <code>dict[str, Any] | None</code> <p>any global settings to add to the mermaid graph. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Composite object in mermaid format.</p> Source code in <code>src/holden/traits.py</code> <pre><code>def to_mermaid(\n    self,\n    path: str | pathlib.Path | None = None,\n    name: str | None = None,\n    settings: dict[str, Any] | None = None) -&gt; str:\n    \"\"\"Converts the stored composite to a mermaid format.\n\n    Args:\n        path: path to export to. Defaults to None.\n        name: name to put in the mermaid str. Defaults to None.\n        settings: any global settings to add to the mermaid graph. Defaults\n            to None.\n\n    Returns:\n        Composite object in mermaid format.\n\n    \"\"\"\n    name = name or utilities._namify(self)\n    return export.to_mermaid(\n        item = self,\n        path = path,\n        name = name,\n        settings = settings)\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Fungible","title":"<code>Fungible()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin requirements for graphs that can be internally transformed.</p>"},{"location":"reference/holden/traits/#holden.traits.Fungible.adjacency","title":"<code>adjacency</code>  <code>property</code>","text":"<p>Returns the stored composite as an Adjacency.</p>"},{"location":"reference/holden/traits/#holden.traits.Fungible.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>Returns the stored composite as an Edges.</p>"},{"location":"reference/holden/traits/#holden.traits.Fungible.matrix","title":"<code>matrix</code>  <code>property</code>","text":"<p>Returns the stored composite as a Matrix.</p>"},{"location":"reference/holden/traits/#holden.traits.Fungible.parallel","title":"<code>parallel</code>  <code>property</code>","text":"<p>Returns the stored composite as a Parallel.</p>"},{"location":"reference/holden/traits/#holden.traits.Fungible.serial","title":"<code>serial</code>  <code>property</code>","text":"<p>Returns the stored composite as a Serial.</p>"},{"location":"reference/holden/traits/#holden.traits.Fungible.from_adjacency","title":"<code>from_adjacency(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from an Adjacency.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_adjacency(cls, item: graphs.Adjacency) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from an Adjacency.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Fungible.from_edges","title":"<code>from_edges(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from an Edges.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_edges(cls, item: graphs.Edges) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from an Edges.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Fungible.from_matrix","title":"<code>from_matrix(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from a Matrix.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_matrix(cls, item: graphs.Matrix) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from a Matrix.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Fungible.from_parallel","title":"<code>from_parallel(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from a Parallel.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_parallel(cls, item: composites.Parallel) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from a Parallel.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Fungible.from_serial","title":"<code>from_serial(item)</code>  <code>classmethod</code>","text":"<p>Creates a composite data structure from a Serial.</p> Source code in <code>src/holden/traits.py</code> <pre><code>@classmethod\ndef from_serial(cls, item: composites.Serial) -&gt; Fungible:\n    \"\"\"Creates a composite data structure from a Serial.\"\"\"\n    return cls(contents = base.transform(\n        item = item,\n        output = base.classify(cls),\n        raise_same_error = False))\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Labeled","title":"<code>Labeled(name=None, contents=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin for labeling a composite object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>designates the name of a class instance that is used for internal and external referencing in a composite object. Defaults to None.</p> <code>None</code> <code>contents</code> <code>Any | None</code> <p>any stored item(s). Defaults to None.</p> <code>None</code>"},{"location":"reference/holden/traits/#holden.traits.Labeled.contents","title":"<code>contents = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/holden/traits/#holden.traits.Labeled._namify","title":"<code>_namify()</code>","text":"<p>Returns str name of an instance.</p> <p>By default, if <code>contents</code> is None, 'none' will be returned. Otherwise, <code>utilities._namify</code> will be called based on the value of the <code>contents</code> attribute and its return value will be returned.</p> <p>For different naming rules, subclasses should override this method, which is automatically called when an instance is initialized.</p> <p>Returns:</p> Type Description <code>str</code> <p>str label for part of a composite data structute.</p> Source code in <code>src/holden/traits.py</code> <pre><code>def _namify(self) -&gt; str:\n    \"\"\"Returns str name of an instance.\n\n    By default, if `contents` is None, 'none' will be returned. Otherwise,\n    `utilities._namify` will be called based on the value of the `contents`\n    attribute and its return value will be returned.\n\n    For different naming rules, subclasses should override this method,\n    which is automatically called when an instance is initialized.\n\n    Returns:\n        str label for part of a composite data structute.\n\n    \"\"\"\n    return 'none' if self.contents is None else utilities._namify(self.contents)\n</code></pre>"},{"location":"reference/holden/traits/#holden.traits.Weighted","title":"<code>Weighted(weight=1.0)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Mixin for weighted nodes.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>float | None</code> <p>the weight of the object. Defaults to 1.0.</p> <code>1.0</code>"},{"location":"reference/holden/traits/#holden.traits.Weighted.weight","title":"<code>weight = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/holden/traverse/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> traverse","text":"<p>Internal storage formats for graphs.</p> Contents <p>walk_adjacency: returns path(s) through an adjacency list. walk_edges: returns path(s) through an edge list. walk_matrix: returns path(s) through an adjacency matrix. walk_parallel: returns path(s) through a parallel structure. walk_serial: returns path(s) through a serial structure.</p> To Do <p>Complete not implemented functions For adjacency matrix walk, consider the efficient approach here:     https://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/</p>"},{"location":"reference/holden/traverse/#holden.traverse.walk_adjacency","title":"<code>walk_adjacency(item, start, stop, path=None)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>The code here is adapted from: https://www.python.org/doc/essays/graphs/</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <code>path</code> <code>Sequence[Hashable] | None</code> <p>a path from <code>start</code> to <code>stop</code>. This is used for recursion within the function to accumulate all possible paths. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_adjacency(\n    item: graphs.Adjacency,\n    start: Hashable,\n    stop: Hashable,\n    path: Sequence[Hashable] | None = None) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    The code here is adapted from: https://www.python.org/doc/essays/graphs/\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n        path: a path from `start` to `stop`. This is used for recursion within\n            the function to accumulate all possible paths. Defaults to None.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    if path is None:\n        path = []\n    path = [*path, start]\n    if start == stop:\n        return [path]\n    if start not in item:\n        return []\n    paths = []\n    for node in item[start]:\n        if node not in path:\n            new_paths = walk_adjacency(\n                item = item,\n                start = node,\n                stop = stop,\n                path = path)\n            paths.extend(iter(new_paths))\n    return paths\n</code></pre>"},{"location":"reference/holden/traverse/#holden.traverse.walk_edges","title":"<code>walk_edges(item, start, stop, path=None)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <code>path</code> <code>Sequence[Hashable] | None</code> <p>a path from <code>start</code> to <code>stop</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_edges(\n    item: graphs.Edges,\n    start: Hashable,\n    stop: Hashable,\n    path: Sequence[Hashable] | None = None) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n        path: a path from `start` to `stop`. Defaults to None.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/traverse/#holden.traverse.walk_matrix","title":"<code>walk_matrix(item, start, stop, path=None)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <code>path</code> <code>Sequence[Hashable] | None</code> <p>a path from <code>start</code> to <code>stop</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_matrix(\n    item: graphs.Matrix,\n    start: Hashable,\n    stop: Hashable,\n    path: Sequence[Hashable] | None = None) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n        path: a path from `start` to `stop`. Defaults to None.\n\n    Returns:\n        A list of possible paths (each path is a list nodes)\n            from `start` to `stop`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/traverse/#holden.traverse.walk_parallel","title":"<code>walk_parallel(item, start, stop)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <p>Returns:</p> Type Description <code>Sequence[Hashable]</code> <p>A list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_parallel(\n    item: composites.Parallel,\n    start: Hashable,\n    stop: Hashable) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        A list of possible paths (each path is a list nodes) from `start` to\n            `stop`.\n\n    \"\"\"\n    return [walk_serial(item = p, start = start, stop = stop) for p in item]\n</code></pre>"},{"location":"reference/holden/traverse/#holden.traverse.walk_serial","title":"<code>walk_serial(item, start, stop)</code>","text":"<p>Returns all paths in <code>item</code> from <code>start</code> to <code>stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item in which to find paths.</p> required <code>start</code> <code>Hashable</code> <p>node to start paths from.</p> required <code>stop</code> <code>Hashable</code> <p>node to stop paths.</p> required <p>Returns:</p> Name Type Description <code>Sequence</code> <code>Sequence[Hashable]</code> <p>a list of possible paths (each path is a list nodes) from <code>start</code> to <code>stop</code>.</p> Source code in <code>src/holden/traverse.py</code> <pre><code>def walk_serial(\n    item: composites.Serial,\n    start: Hashable,\n    stop: Hashable) -&gt; Sequence[Hashable]:\n    \"\"\"Returns all paths in `item` from `start` to `stop`.\n\n    Args:\n        item: item in which to find paths.\n        start: node to start paths from.\n        stop: node to stop paths.\n\n    Returns:\n        Sequence: a list of possible paths (each path is a list nodes) from\n            `start` to `stop`.\n\n    \"\"\"\n    index_start = item.index(start)\n    index_stop = item.index(stop)\n    if index_stop &gt; len(item):\n        path = item[index_start:]\n    else:\n        path = item[index_start:index_stop]\n    return path\n</code></pre>"},{"location":"reference/holden/utilities/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utilities","text":"<p>Shared tools.</p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/holden/utilities/#holden.utilities._iterify","title":"<code>_iterify(item)</code>","text":"<p>Returns <code>item</code> as an iterable, but does not iterate str types.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to turn into an iterable</p> required <p>Returns:</p> Type Description <code>Iterable</code> <p>Iterable of <code>item</code>. A <code>str</code> type will be stored as a single item in an Iterable wrapper.</p> Source code in <code>src/holden/utilities.py</code> <pre><code>def _iterify(item: Any) -&gt; Iterable:\n    \"\"\"Returns `item` as an iterable, but does not iterate str types.\n\n    Args:\n        item: item to turn into an iterable\n\n    Returns:\n        Iterable of `item`. A `str` type will be stored as a single item in an\n            Iterable wrapper.\n\n    \"\"\"\n    if item is None:\n        return iter(())\n    elif isinstance(item, str | bytes):\n        return iter([item])\n    else:\n        try:\n            return iter(item)\n        except TypeError:\n            return iter((item,))\n</code></pre>"},{"location":"reference/holden/utilities/#holden.utilities._namify","title":"<code>_namify(item, /, default=None)</code>","text":"<p>Returns str name representation of <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to determine a str name.</p> required <code>default</code> <code>str | None</code> <p>default name to return if other methods at name creation fail.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>A name representation of <code>item</code>.</p> Source code in <code>src/holden/utilities.py</code> <pre><code>def _namify(item: Any, /, default: str | None = None) -&gt; str | None:\n    \"\"\"Returns str name representation of `item`.\n\n    Args:\n        item: item to determine a str name.\n        default: default name to return if other methods at name creation fail.\n\n    Returns:\n        A name representation of `item`.\n\n    \"\"\"\n    if isinstance(item, str):\n        return item\n    elif (\n        hasattr(item, 'name')\n        and not inspect.isclass(item)\n        and isinstance(item.name, str)):\n        return item.name\n    else:\n        try:\n            return _snakify(item.__name__)\n        except AttributeError:\n            if item.__class__.__name__ is not None:\n                return _snakify(item.__class__.__name__)\n            else:\n                return default\n</code></pre>"},{"location":"reference/holden/utilities/#holden.utilities._pathlibify","title":"<code>_pathlibify(item)</code>","text":"<p>Converts string <code>path</code> to pathlib.Path object.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>either a string of a path or a pathlib.Path object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path object.</p> Source code in <code>src/holden/utilities.py</code> <pre><code>def _pathlibify(item: str | pathlib.Path) -&gt; pathlib.Path:\n    \"\"\"Converts string `path` to pathlib.Path object.\n\n    Args:\n        item: either a string of a path or a pathlib.Path object.\n\n    Raises:\n        TypeError if `path` is neither a str or pathlib.Path type.\n\n    Returns:\n        pathlib.Path object.\n\n    \"\"\"\n    if isinstance(item, str):\n        return pathlib.Path(item)\n    elif isinstance(item, pathlib.Path):\n        return item\n    else:\n        raise TypeError('item must be str or pathlib.Path type')\n</code></pre>"},{"location":"reference/holden/utilities/#holden.utilities._snakify","title":"<code>_snakify(item)</code>","text":"<p>Converts a capitalized str to snake case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>'item' converted to snake case.</p> Source code in <code>src/holden/utilities.py</code> <pre><code>def _snakify(item: str) -&gt; str:\n    \"\"\"Converts a capitalized str to snake case.\n\n    Args:\n        item: str to convert.\n\n    Returns:\n        'item' converted to snake case.\n\n    \"\"\"\n    item = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', item)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', item).lower()\n</code></pre>"},{"location":"reference/holden/utilities/#holden.utilities._typify","title":"<code>_typify(item)</code>","text":"<p>Converts stings to appropriate, supported datatypes.</p> <p>The method converts strings to list (if ', ' is present), int, float, or bool datatypes based upon the content of the string. If no alternative datatype is found, the item is returned in its original form.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>string to be converted to appropriate datatype.</p> required <p>Returns:</p> Type Description <code>list[Any] | int | float | bool | str</code> <p>Converted item.</p> Source code in <code>src/holden/utilities.py</code> <pre><code>def _typify(item: str) -&gt; list[Any] | int | float | bool | str:\n    \"\"\"Converts stings to appropriate, supported datatypes.\n\n    The method converts strings to list (if ', ' is present), int, float,\n    or bool datatypes based upon the content of the string. If no\n    alternative datatype is found, the item is returned in its original\n    form.\n\n    Args:\n        item: string to be converted to appropriate datatype.\n\n    Returns:\n        Converted item.\n\n    \"\"\"\n    if not isinstance(item, str):\n        return item\n    try:\n        return int(item)\n    except ValueError:\n        try:\n            return float(item)\n        except ValueError:\n            if item.lower() in {'true', 'yes'}:\n                return True\n            elif item.lower() in {'false', 'no'}:\n                return False\n            elif ', ' in item:\n                item = item.split(', ')\n                return [_typify(i) for i in item]\n            else:\n                return item\n</code></pre>"},{"location":"reference/holden/utilities/#holden.utilities._windowify","title":"<code>_windowify(item, length, fill_value=None, step=1)</code>","text":"<p>Returns a sliding window of <code>length</code> over <code>item</code>.</p> <p>This code is adapted from more_itertools.windowed to remove a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Sequence[Any]</code> <p>sequence from which to return windows.</p> required <code>length</code> <code>int</code> <p>length of window.</p> required <code>fill_value</code> <code>Optional[Any]</code> <p>value to use for items in a window that do not exist when length &gt; len(item). Defaults to None.</p> <code>None</code> <code>step</code> <code>Optional[Any]</code> <p>number of items to advance between each window. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>length</code> is less than 0 or step is less than 1.</p> <p>Returns:</p> Type Description <code>Sequence[Any]</code> <p>Sequence[Any]: windowed sequence derived from arguments.</p> Source code in <code>src/holden/utilities.py</code> <pre><code>def _windowify(\n    item: Sequence[Any],\n    length: int,\n    fill_value: Any | None = None,\n    step: int | None = 1) -&gt; Sequence[Any]: # type: ignore  # noqa: PGH003\n    \"\"\"Returns a sliding window of `length` over `item`.\n\n    This code is adapted from more_itertools.windowed to remove a dependency.\n\n    Args:\n        item (Sequence[Any]): sequence from which to return windows.\n        length (int): length of window.\n        fill_value (Optional[Any]): value to use for items in a window that do\n            not exist when length &gt; len(item). Defaults to None.\n        step (Optional[Any]): number of items to advance between each window.\n            Defaults to 1.\n\n    Raises:\n        ValueError: if `length` is less than 0 or step is less than 1.\n\n    Returns:\n        Sequence[Any]: windowed sequence derived from arguments.\n\n    \"\"\"\n    if length &lt; 0:\n        raise ValueError('length must be &gt;= 0')\n    if length == 0:\n        yield ()\n        return\n    if step &lt; 1:\n        raise ValueError('step must be &gt;= 1')\n    window = collections.deque(maxlen = length)\n    i = length\n    for _ in map(window.append, item):\n        i -= 1\n        if not i:\n            i = step\n            yield tuple(window)\n    size = len(window)\n    if size &lt; length:\n        yield tuple(itertools.chain(\n            window, itertools.repeat(fill_value, length - size)))\n    elif 0 &lt; i &lt; min(step, length):\n        window += (fill_value,) * i\n        yield tuple(window)\n</code></pre>"},{"location":"reference/holden/workshop/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> workshop","text":"<p>Functions to change the internal storage format for a data structure.</p> Contents <p>add_transformer adjacency_to_edges adjacency_to_matrix adjacency_to_serial adjacency_to_parallel edges_to_adjacency edges_to_matrix edges_to_serial edges_to_parallel matrix_to_adjacency matrix_to_edges matrix_to_serial matrix_to_parallel serial_to_adjacency serial_to_edges serial_to_matrix serial_to_parallel parallel_to_adjacency parallel_to_edges parallel_to_matrix parallel_to_serial</p> To Do <p>Implement remaining functions.</p>"},{"location":"reference/holden/workshop/#holden.workshop._TRANSFORMER","title":"<code>_TRANSFORMER = lambda x, y: f'f{x}_to_{y}'</code>  <code>module-attribute</code>","text":"<p>Transformers</p>"},{"location":"reference/holden/workshop/#holden.workshop.add_transformer","title":"<code>add_transformer(name, item)</code>","text":"<p>Adds a transformer to this module's namespace.</p> <p>This allows the function to be found by the <code>transform</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the transformer function. It needs to be in the <code>_TRANSFORMER</code> format.</p> required <code>item</code> <code>Callable[[Composite]]</code> <p>callable transformer which should have a single parameter, item which should be a Composite type.</p> required Source code in <code>src/holden/workshop.py</code> <pre><code>def add_transformer(name: str, item: Callable[[base.Composite]]) -&gt; None:\n    \"\"\"Adds a transformer to this module's namespace.\n\n    This allows the function to be found by the `transform` function.\n\n    Args:\n        name: name of the transformer function. It needs to be in the\n            `_TRANSFORMER` format.\n        item: callable transformer which should have a single parameter, item\n            which should be a Composite type.\n\n    \"\"\"\n    globals()[name] = item\n    return\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.adjacency_to_edges","title":"<code>adjacency_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Type Description <code>Edges</code> <p>Edges derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_edges(item: graphs.Adjacency) -&gt; graphs.Edges:\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges derived from `item`.\n\n    \"\"\"\n    edges = []\n    for node, connections in item.items():\n        edges.extend((node, connection) for connection in connections)\n    return tuple(edges)\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.adjacency_to_matrix","title":"<code>adjacency_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_matrix(item: graphs.Adjacency) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    names = list(item.keys())\n    matrix = []\n    for i in range(len(item)):\n        matrix.append([0] * len(item))\n        for j in item[i]:\n            matrix[i][j] = 1\n    return matrix, names\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.adjacency_to_parallel","title":"<code>adjacency_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a parallel structure.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to a parallel structure.</p> required <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel structure derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_parallel(item: graphs.Adjacency) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a parallel structure.\n\n    Args:\n        item: item to convert to a parallel structure.\n\n    Returns:\n        Parallel structure derived from `item`.\n\n    \"\"\"\n    roots = get_roots_adjacency(item = item)\n    endpoints = get_endpoints_adjacency(item = item)\n    all_paths = []\n    for start in roots:\n        for end in endpoints:\n            if paths := traverse.walk_adjacency(\n                    item=item, start=start, stop=end):\n                if all(isinstance(path, Hashable) for path in paths):\n                    all_paths.append(paths)\n                else:\n                    all_paths.extend(paths)\n    return all_paths\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.adjacency_to_serial","title":"<code>adjacency_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Adjacency</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def adjacency_to_serial(item: graphs.Adjacency) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    all_parallel = adjacency_to_parallel(item = item)\n    if len(all_parallel) == 1:\n        return all_parallel[0]\n    else:\n        return list(itertools.chain.from_iterable(all_parallel))\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.edges_to_adjacency","title":"<code>edges_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_adjacency(item: graphs.Edges) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    adjacency = collections.defaultdict(set)\n    for edge_pair in item:\n        if edge_pair[0] not in adjacency:\n            adjacency[edge_pair[0]] = {edge_pair[1]}\n        else:\n            adjacency[edge_pair[0]].add(edge_pair[1])\n        if edge_pair[1] not in adjacency:\n            adjacency[edge_pair[1]] = set()\n    return adjacency\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.edges_to_matrix","title":"<code>edges_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_matrix(item: graphs.Edges) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.edges_to_parallel","title":"<code>edges_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a Parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to a Parallel.</p> required <p>Returns:</p> Name Type Description <code>Parallel</code> <code>Parallel</code> <p>derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_parallel(item: graphs.Edges) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a Parallel.\n\n    Args:\n        item: item to convert to a Parallel.\n\n    Returns:\n        Parallel: derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.edges_to_serial","title":"<code>edges_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Edges</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def edges_to_serial(item: graphs.Edges) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.get_endpoints_adjacency","title":"<code>get_endpoints_adjacency(item)</code>","text":"<p>Returns the endpoints in <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def get_endpoints_adjacency(item: graphs.Adjacency) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the endpoints in `item`.\"\"\"\n    return [k for k in item if not item[k]]\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.get_roots_adjacency","title":"<code>get_roots_adjacency(item)</code>","text":"<p>Returns the roots in <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def get_roots_adjacency(item: graphs.Adjacency) -&gt; MutableSequence[Hashable]:\n    \"\"\"Returns the roots in `item`.\"\"\"\n    stops = list(itertools.chain.from_iterable(item.values()))\n    return [k for k in item if k not in stops]\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.matrix_to_adjacency","title":"<code>matrix_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_adjacency(item: graphs.Matrix) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    matrix = item[0]\n    names = item[1]\n    name_mapping = dict(zip(range(len(matrix)), names, strict = False))\n    raw_adjacency = {\n        i: [j for j, adjacent in enumerate(row) if adjacent]\n        for i, row in enumerate(matrix)}\n    adjacency = collections.defaultdict(set)\n    for key, value in raw_adjacency.items():\n        new_key = name_mapping[key]\n        new_values = {name_mapping[edge] for edge in value}\n        adjacency[new_key] = new_values\n    return adjacency\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.matrix_to_edges","title":"<code>matrix_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Name Type Description <code>Edges</code> <code>Edges</code> <p>derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_edges(item: graphs.Matrix) -&gt; graphs.Edges:\n    # sourcery skip: for-append-to-extend\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges: derived from `item`.\n\n    \"\"\"\n    matrix = item[0]\n    labels = item[1]\n    edges = []\n    for i in enumerate(matrix):\n        for j in enumerate(matrix):\n            if matrix[i][j] &gt; 0:\n                edges.append((labels[i], labels[j]))\n    return edges\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.matrix_to_parallel","title":"<code>matrix_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a Parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to a Parallel.</p> required <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_parallel(item: graphs.Matrix) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a Parallel.\n\n    Args:\n        item: item to convert to a Parallel.\n\n    Returns:\n        Parallel derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.matrix_to_serial","title":"<code>matrix_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Matrix</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def matrix_to_serial(item: graphs.Matrix) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.parallel_to_adjacency","title":"<code>parallel_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_adjacency(item: composites.Parallel) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    adjacency = collections.defaultdict(set)\n    for serial in item:\n        pipe_adjacency = serial_to_adjacency(item = serial)\n        for key, value in pipe_adjacency.items():\n            if key in adjacency:\n                for inner_value in value:\n                    if inner_value not in adjacency:\n                        adjacency[key].add(inner_value)\n            else:\n                adjacency[key] = value\n    return adjacency\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.parallel_to_edges","title":"<code>parallel_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Type Description <code>Edges</code> <p>Edges derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_edges(item: composites.Parallel) -&gt; graphs.Edges:\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.parallel_to_matrix","title":"<code>parallel_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_matrix(item: composites.Parallel) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.parallel_to_serial","title":"<code>parallel_to_serial(item)</code>","text":"<p>Converts <code>item</code> to a Serial.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Parallel</code> <p>item to convert to a Serial.</p> required <p>Returns:</p> Type Description <code>Serial</code> <p>Serial derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def parallel_to_serial(item: composites.Parallel) -&gt; composites.Serial:\n    \"\"\"Converts `item` to a Serial.\n\n    Args:\n        item: item to convert to a Serial.\n\n    Returns:\n        Serial derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.serial_to_adjacency","title":"<code>serial_to_adjacency(item)</code>","text":"<p>Converts <code>item</code> to an Adjacency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to an Adjacency.</p> required <p>Returns:</p> Type Description <code>Adjacency</code> <p>Adjacency derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_adjacency(item: composites.Serial) -&gt; graphs.Adjacency:\n    \"\"\"Converts `item` to an Adjacency.\n\n    Args:\n        item: item to convert to an Adjacency.\n\n    Returns:\n        Adjacency derived from `item`.\n\n    \"\"\"\n    if check.is_parallel(item = item):\n        return parallel_to_adjacency(item = item)\n    if not isinstance(item, (Collection)) or isinstance(item, str):\n        item = [item]\n    adjacency = collections.defaultdict(set)\n    if len(item) == 1:\n        adjacency.update({item[0]: set()})\n    else:\n        edges = list(utilities._windowify(item, 2))\n        for edge_pair in edges:\n            if edge_pair[0] in adjacency:\n                adjacency[edge_pair[0]].add(edge_pair[1])\n            else:\n                adjacency[edge_pair[0]] = {edge_pair[1]}\n    return adjacency\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.serial_to_edges","title":"<code>serial_to_edges(item)</code>","text":"<p>Converts <code>item</code> to an Edges.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to an Edges.</p> required <p>Returns:</p> Type Description <code>Edges</code> <p>Edges derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_edges(item: composites.Serial) -&gt; graphs.Edges:\n    \"\"\"Converts `item` to an Edges.\n\n    Args:\n        item: item to convert to an Edges.\n\n    Returns:\n        Edges derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.serial_to_matrix","title":"<code>serial_to_matrix(item)</code>","text":"<p>Converts <code>item</code> to a Matrix.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to a Matrix.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>Matrix derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_matrix(item: composites.Serial) -&gt; graphs.Matrix:\n    \"\"\"Converts `item` to a Matrix.\n\n    Args:\n        item: item to convert to a Matrix.\n\n    Returns:\n        Matrix derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/holden/workshop/#holden.workshop.serial_to_parallel","title":"<code>serial_to_parallel(item)</code>","text":"<p>Converts <code>item</code> to a Parallel.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Serial</code> <p>item to convert to a Parallel.</p> required <p>Returns:</p> Type Description <code>Parallel</code> <p>Parallel derived from <code>item</code>.</p> Source code in <code>src/holden/workshop.py</code> <pre><code>def serial_to_parallel(item: composites.Serial) -&gt; composites.Parallel:\n    \"\"\"Converts `item` to a Parallel.\n\n    Args:\n        item: item to convert to a Parallel.\n\n    Returns:\n        Parallel derived from `item`.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"}]}